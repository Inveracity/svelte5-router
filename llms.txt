# Actions

The Svelte router provides powerful actions that can be used to enhance your routing experience. These actions are designed to be used with anchor (`<a>`) elements to handle navigation and manage active states.

## Available Actions

| Action | Description |
|--------|-------------|
| [`route`](#route) | Manages both navigation and active states of links. |
| [`active`](#active) | Handles active state management for styling links. |  

## Examples

### Basic Navigation Link

```svelte
<a href="/home" use:route>Home</a>
```

### Active State with Multiple Classes

```svelte
<a 
  href="/profile" 
  use:route={{
    default: { class: ['text-gray-600', 'hover:text-gray-900'] },
    active: { class: ['text-blue-600', 'font-bold'] }
  }}
>
  Profile
</a>
```

### Exact Path Matching

```svelte
<a 
  href="/settings" 
  use:route={{
    active: {
      class: 'active-link',
      absolute: true // Only active when path exactly matches /settings
    }
  }}
>
  Settings
</a>
```

### Query String Sensitive Navigation

```svelte
<a 
  href="/search?type=users" 
  use:route={{
    active: {
      class: 'active-search',
      querystring: true // Only active when querystring matches exactly
    }
  }}
>
  User Search
</a>
```

### Notes

- The `route` action automatically prevents default link behavior and handles navigation through the History API.
- When using `active`, you'll need to handle navigation separately if needed.
- Classes are applied dynamically based on the current route state.
- The `absolute` option is useful for preventing parent routes from being marked as active when child routes are active.
- The `querystring` option allows for precise matching including query parameters.

---

## `route`

The `route` action is the primary action for handling routing in your application. It manages both navigation and active states of links.

```svelte
<a href="/dashboard" use:route>Dashboard</a>
```

The `route` action accepts an options object with the following configuration:

```typescript
{
  default?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  },
  active?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  },
  loading?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  },
  disabled?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  }
}
```

- `default`: Options applied when the route is inactive.
- `active`: Options applied when the route is active.
- `loading`: Options applied when the route is loading.
- `disabled`: Options applied when the route is disabled.

Each state accepts the following properties:

- `absolute`: When `true`, effects only apply on exact path matches.
- `querystring`: When `true`, effects only apply when querystring exactly matches.
- `class`: CSS class(es) to apply when the state is active.

Example with options:

```svelte
<a 
  href="/dashboard" 
  use:route={{
    default: { class: 'text-gray-600' },
    active: { 
      class: 'text-blue-600 font-bold',
      absolute: true 
    }
  }}
>
  Dashboard
</a>
```

## `active`

The `active` action is a simplified version of `route` that only handles active state management without handling navigation events. This is useful when you want to style links based on the current route but handle navigation differently.

```svelte
<a href="/dashboard" use:active>Dashboard</a>
```

The `active` action accepts a subset of the route options, focusing only on the active state configuration:

```typescript
{
  active?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  }
}
```

Example with options:

```svelte
<a 
  href="/dashboard" 
  use:active={{
    active: {
      class: ['text-blue-600', 'font-bold'],
      absolute: true,
      querystring: true
    }
  }}
>
  Dashboard
</a>
```
## [2.15.2] - 2025-05-26

### 🐛 Bug Fixes

- Support list of defaults for route; fixes #76

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.15.1] - 2025-05-25

### 🐛 Bug Fixes

- Route result serialization to string; closes #73

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.15.0] - 2025-05-24

### 🚀 Features

- Additional props support @ <Router/> -> [child], closes #70

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.14.1] - 2025-03-27

### 🐛 Bug Fixes

- Hooks return to false; closes #63

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- *(docs)* Better explain named params

<!-- generated by git-cliff -->
## [2.14.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.13.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.12.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.11.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.10.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.9.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.8.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.7.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.6.1] - 2025-03-05

### ⚙️ Miscellaneous Tasks

- Vercel cicd
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.6.0] - 2025-03-05

### 🚀 Features

- *(demo)* Awesomify /protected demo with making it rainr

### 🐛 Bug Fixes

- *(demo)* Show random querystring usage
- *(demo)* Show random querystring usage

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Clean up docs
- Clean up docs
- Vercel cicd
- Vercel cicd
- Vercel cicd
- Vercel cicd
- Vercel cicd
- Vercel cicd

<!-- generated by git-cliff -->
## [2.5.0] - 2025-03-05

### 🚀 Features

- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.4.0] - 2025-03-05

### 🚀 Features

- *(demo)* Awesomify /protected demo with making it rainr

### 🐛 Bug Fixes

- Cicd
- Cicd

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.34] - 2025-03-05

### 🐛 Bug Fixes

- Cicd
- Better regexp instance handling
- Cicd

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.33] - 2025-03-04

### 🐛 Bug Fixes

- Cicd

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.32] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.31] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.30] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.29] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.28] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.27] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.26] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.25] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.24] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.23] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.22] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.21] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.20] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.19] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.18] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.17] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.16] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.15] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.14] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.13] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.12] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.11] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.10] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.9] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.8] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.7] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.6] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.5] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.4] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.3] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.2] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.1] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.0] - 2025-03-04

### 🚀 Features

- Query param matchers; fix: same route, diff params #54
- Query param matchers; fix: same route, diff params #54; tracing
- Query param matchers; fix: same route, diff params #54; tracing
- Query param matchers; fix: same route, diff params #54; tracing
- Query param matchers; fix: same route, diff params #54; tracing

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.7] - 2025-02-28

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.6] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature
- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.5] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.4] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.3] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.2] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature
- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.1] - 2025-02-28

### 📚 Documentation

- Update statuses doc
- Update statuses doc

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.0] - 2025-02-28

### 🚀 Features

- Better status mapping; added callable status code handlers

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.1.1] - 2025-02-28

### 🐛 Bug Fixes

- Options handling for <a> tags proper

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.1.0] - 2025-02-28

### 🚀 Features

- /protected demo
- /protected demo
- /protected demo
- /protected demo

### 💼 Other

- Refactor

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.57] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.56] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.55] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.54] - 2025-02-28

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.53] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.52] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.51] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.50] - 2025-02-27

### 📚 Documentation

- Add transitions demo

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.49] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.48] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.47] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.46] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.45] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.44] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release
- Prep cicd for v2 release
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.43] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.42] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.41] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.40] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release

<!-- generated by git-cliff -->
# Debugging

There are a few way to debug things.

## Debug Logger

In your `vite.config.ts` file, you can add the following:

```ts
export default defineConfig({
  plugins: [svelte()],
  build: {
    sourcemap: true // If you want to use a debugger, add this!
  },
  define: {
    // Tell the router to log when we're in debug mode.
    // Otherwise, this statement is removed by the compiler (known as tree-shaking)
    // and all subsequent log statements are removed at build time:
    'import.meta.env.SPA_ROUTER': {
      logLevel: "debug"
    },
  }
});
```

This allows us to log when we're in debug mode otherwise
statements like this are removed by the compiler (known astree-shaking):

```ts
if (import.meta.env.SPA_ROUTER && import.meta.env.SPA_ROUTER.logLevel === "debug") {
  log.debug(this.config.id, "unregistered router instance", {
    id: this.config.id,
    routes: this.routes.size
  });
}
```

Putting it all together:

```svelte
<script lang="ts">
  import { Router, type RouterInstance } from "@mateothegreat/svelte5-router";

  let instance: RouterInstance;

  if (import.meta.env.SPA_ROUTER && import.meta.env.SPA_ROUTER.logLevel === "debug") {
    log.debug(instance.id, "dumping routes", {
      config: instance.config,
      routes: instance.routes,
      current: instance.current,
      navigating: instance.navigating
    });
  }
</script>

<Router bind:instance {routes}>
```

Example output:

![debug](./assets/debugging-logger.png)
# Router Architecture Diagrams

This document contains Mermaid diagrams that illustrate the architecture and flow of the Svelte 5 Router. These diagrams are designed to help you understand how the router works internally.

## 1. Router Architecture

Shows the high-level architecture of the router, including how URL changes flow through the system to component rendering.

<div align="center">

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#fff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#64748b',
    'secondaryColor': '#4ade80',
    'tertiaryColor': '#f472b6'
  }
}}%%
graph TB
    A[Browser URL Change] -->|Triggers| B[RouterInstance]
    B -->|Registers| C[Registry]
    B -->|Evaluates| D[Route Matching]
    D -->|Checks| E[Path Matching]
    D -->|Checks| F[Query Matching]
    E --> G[Route Resolution]
    F --> G
    G -->|Pre Hooks| H[Route Guards]
    H -->|Success| I[Component Rendering]
    H -->|Failure| J[Redirect/Deny]
    I -->|Post Hooks| K[Final Render]
    
    style A fill:#3b82f6,stroke:#1d4ed8
    style B fill:#4ade80,stroke:#16a34a
    style C fill:#f472b6,stroke:#db2777
    style D fill:#4ade80,stroke:#16a34a
    style G fill:#f472b6,stroke:#db2777
    style H fill:#3b82f6,stroke:#1d4ed8
    style I fill:#4ade80,stroke:#16a34a 
```

</div>

## 2. Routing Lifecycle

A sequence diagram showing the temporal flow of routing operations from URL change to final render.

<div align="center">

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#fff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#64748b',
    'secondaryColor': '#4ade80',
    'tertiaryColor': '#f472b6'
  }
}}%%
sequenceDiagram
    participant U as User/Browser
    participant R as Router
    participant RI as RouterInstance
    participant RG as Registry
    participant H as Hooks
    participant C as Component

    U->>R: URL Change
    R->>RG: Check Registration
    RG-->>R: Return Instance
    R->>RI: Handle State Change
    RI->>RI: Evaluate Route
    RI->>H: Execute Pre-Hooks
    alt Hook Success
        H-->>RI: Continue
        RI->>C: Render Component
        RI->>H: Execute Post-Hooks
        H-->>RI: Complete
    else Hook Failure
        H-->>RI: Abort/Redirect
        RI->>U: Navigate Away
    end 
```

</div>

## 3. Route Evaluation

A detailed flowchart showing how routes are evaluated, including path matching, query parameter checking, and hook execution.

<div align="center">

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#fff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#64748b',
    'secondaryColor': '#4ade80',
    'tertiaryColor': '#f472b6'
  }
}}%%
flowchart TD
    A[Route Evaluation Start] --> B{Check Path Type}
    B -->|String| C[Direct Match]
    B -->|RegExp| D[Pattern Match]
    B -->|Function| E[Custom Match]
    
    C --> F{Path Matches?}
    D --> F
    E --> F
    
    F -->|Yes| G[Check Query Parameters]
    F -->|No| H[Try Next Route]
    
    G --> I{Query Matches?}
    I -->|Yes| J[Create Route Result]
    I -->|No| H
    
    H --> K{More Routes?}
    K -->|Yes| B
    K -->|No| L[Use Default Route]
    
    J --> M[Execute Pre Hooks]
    L --> M
    
    style A fill:#3b82f6,stroke:#1d4ed8
    style B fill:#4ade80,stroke:#16a34a
    style F fill:#f472b6,stroke:#db2777
    style I fill:#f472b6,stroke:#db2777
    style J fill:#4ade80,stroke:#16a34a
    style M fill:#3b82f6,stroke:#1d4ed8 
```

</div>

## 4. Component Hierarchy

Shows the relationship between different components in the router system.

<div align="center">

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#fff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#64748b',
    'secondaryColor': '#4ade80',
    'tertiaryColor': '#f472b6'
  }
}}%%
graph TD
    A[Router Component] -->|Creates| B[RouterInstance]
    B -->|Registers with| C[Registry]
    B -->|Manages| D[Route Collection]
    D -->|Contains| E[Route Configurations]
    E -->|Has| F[Path Patterns]
    E -->|Has| G[Query Patterns]
    E -->|Has| H[Hooks]
    E -->|Renders| I[Route Components]
    
    style A fill:#3b82f6,stroke:#1d4ed8
    style B fill:#4ade80,stroke:#16a34a
    style C fill:#f472b6,stroke:#db2777
    style D fill:#4ade80,stroke:#16a34a
    style E fill:#f472b6,stroke:#db2777 
```

</div>
# Getting Started

## Installation

```bash
npm install @mateothegreat/svelte5-router
```

## Usage

In your `app.svelte` file, you can use the `Router` component to render your routes:

```svelte
<script lang="ts">
  import { Router, type RouteConfig } from "@mateothegreat/svelte5-router";

  const routes: RouteConfig[] = [
    {
      component: Home
    }
    {
      path: "products",
      component: Products
    },
    {
      path: "settings",
      component: Settings
    }
  ];
</script>

<Router {routes} />
```

When you navigate to the root route, the `Home` component will be rendered.

When you navigate to the `/products` route, the `Products` component will be rendered.

When you navigate to the `/settings` route, the `Settings` component will be rendered.
# Helpers

There are a few helpers that are available to you when using the router.

## `goto(path: string, queryParams?: Record<string, string>)`

Navigates to the given path by calling `goto("/path")`.

Example:

```ts
goto("/foo", { bar: "baz" });
```

This will navigate to `/foo?bar=baz`.

## `query(key: string): string | null`

Returns the value of the query parameter for the given key or null if the key does not exist.

## The `QueryString` class

A helper class for working with the query string.

> Check it out at [src/lib/query.svelte.ts](../src/lib/query.svelte.ts).
> or import it with:
>
> ```ts
> import { QueryString } from "@mateothegreat/svelte5-router";
> ```
>
> and start using it now!

Basic usage:

```ts
import { QueryString } from "@mateothegreat/svelte5-router";

const query = new QueryString();

query.get("foo", "bar"); // "bar"
query.set("baz", "qux");
query.toString();        // "foo=bar&baz=qux"
```

Using it with navigation:

```ts
import { QueryString } from "@mateothegreat/svelte5-router";

const query = new QueryString();

// ...
query.set("foo", "baz");
query.set("baz", "qux");
// ...

query.goto("/test"); // Navigates to "/test?foo=baz&baz=qux"
```

You can also pass a query object to the `goto` method:

```ts
goto("/test", { foo: "baz" }); // Navigates to "/test?foo=baz"
```
# Routing Hooks

 | Order | Event  | Scope       | Description                                |
 | ----- | ------ | ----------- | ------------------------------------------ |
 | 1.    | `pre`  | `<Router/>` | Always runs *before* a route is attempted. |
 | 2.    | `pre`  | `Route`     | Runs *before* the route is rendered.       |
 | 3.    | `post` | `Route`     | Runs *after* the route is rendered.        |
 | 4.    | `post` | `<Router/>` | Always runs *after* a route is rendered.   |

```ts
import { goto, type RouteResult } from "@mateothegreat/svelte5-router";

export const authGuard = async (route: RouteResult): Promise<boolean> => {
  console.log("simulating some login/auth check...");
  // Crude example of checking if the user is logged in. A more
  // sophisticated example would use a real authentication system
  // and a server-side API.
  if (!localStorage.getItem("token")) {
    console.warn("redirecting to denied");
    goto("/protected/denied");
    return false;
  }
  return true;
}

const globalPostHook1 = (route: RouteResult): boolean => {
  console.warn("globalPostHook1", route);
  // Return true so that the route can continue down its evaluation path.
  return true;
};

const globalPostHook2 = async (route: RouteResult): Promise<boolean> => {
  console.warn("globalPostHook2", route);
  // Return true so that the route can continue down its evaluation path.
  return true;
};
```

You can pass an array or single method for the `pre` and `post` hooks and you can
also mix and match asynchronous and synchronous hooks.

```svelte
<Router
  {routes}
  hooks={{
    pre: authGuard,
    post: [
      globalPostHook1,
      globalPostHook2
    ]
  }}
/>
```
# Passing Props

You can pass props to a route by using the `props` property on any route.

These props will be passed to the component via `$props()`:

```ts
const routes: RouteConfig[] = [
  {
    path: /\/(?<child>.*)/,
    component: DisplayParams,
    props: {
      randomId: Math.random().toString(36).substring(2, 15),
      someUserStuff: {
        username: "mateothegreat",
        userAgent: navigator.userAgent
      }
    }
  }
];
```

Then, in your component, you can access the prop like this:

```svelte
<script lang="ts">
  let { route } = $props();
</script>

<pre>{JSON.stringify(route, null, 2)}</pre>
```

When you navigate to `/props/bar?someQueryParam=123`, the output will be:

```json
{
  "route": {
    "params": {
      "child": "bar"
    },
    "props": {
      "randomId": "y3pbfi1mgmg",
      "someUserStuff": {
        "username": "mateothegreat",
        "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"
      }
    },
    "query": {
      "someQueryParam": "123"
    },
    "name": "props-fancy-regex",
    "path": {
      "before": "/\\/(?<child>.*)/",
      "after": "/props/bar"
    }
  }
}
```
# Svelte 5 SPA Router 🚀 🔥

![logo](https://raw.githubusercontent.com/mateothegreat/svelte5-router/refs/heads/dev/docs/assets/logo-1000px.png)

<img src="https://raw.githubusercontent.com/mateothegreat/svelte5-router/refs/heads/dev/docs/assets/coverage.svg?sanitize=true" />

An SPA router for Svelte that allows you to divide & conquer your app with nested routers, snippets, and more.

> [!NOTE]
> Live demo: <https://demo.router.svelte.spa>
>
> API documentation: <https://docs.router.svelte.spa>

## Features

- Built for Svelte 5 🚀!
- Divide & conquer - use nested routers all over the place.
- Use components, snippets, or both 🔥!
- Use regex paths (e.g. `/foo/(.*?)/bar`) and/or named parameters together.
- Use async routes simply with `component: async () => import("./my-component.svelte")`.
- Add hooks to your routes to control the navigation flow 🔧.
- Automagic styling of your anchor tags 💄.
- Helper methods 🛠️ to make your life easier.
- Debugging tools included 🔍.

## Installation

```bash
npm install @mateothegreat/svelte5-router
```

## Table of Contents

- [Getting Started](./getting-started.md)
- [Routing](./routing.md)
- [Hooks](./hooks.md)
- [Actions](./actions.md)
- [Helper Methods](./helpers.md)
- [Default Status Mapping](./statuses.md)
- [The Router Registry](./registry.md)
- [Route Styling](./styling.md)
- [Accessing Props](./props.md)
- [Debugging](./debugging.md)
- [Diagrams](./diagrams.md)

> [!NOTE]
> Include [llms.txt](./llms.txt) to your local LLM to get add rich context to your tasks by referencing `https://raw.githubusercontent.com/mateothegreat/svelte5-router/refs/heads/main/llms.txt`.

## How it works

When the browser URL changes, the router instance is triggered. It then registers the route in the registry, evaluates the route matching, and resolves the route.

<div align="center">

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#2563eb',
    'primaryTextColor': '#fff',
    'primaryBorderColor': '#1e40af',
    'lineColor': '#64748b',
    'secondaryColor': '#4ade80',
    'tertiaryColor': '#f472b6'
  }
}}%%
flowchart TD
    A[Route Evaluation Start] --> B{Check Path Type}
    B -->|String| C[Direct Match]
    B -->|RegExp| D[Pattern Match]
    B -->|Function| E[Custom Match]
    
    C --> F{Path Matches?}
    D --> F
    E --> F
    
    F -->|Yes| G[Check Query Parameters]
    F -->|No| H[Try Next Route]
    
    G --> I{Query Matches?}
    I -->|Yes| J[Create Route Result]
    I -->|No| H
    
    H --> K{More Routes?}
    K -->|Yes| B
    K -->|No| L[Use Default Route]
    
    J --> M[Execute Pre Hooks]
    L --> M
    
    style A fill:#3b82f6,stroke:#1d4ed8
    style B fill:#4ade80,stroke:#16a34a
    style F fill:#f472b6,stroke:#db2777
    style I fill:#f472b6,stroke:#db2777
    style J fill:#4ade80,stroke:#16a34a
    style M fill:#3b82f6,stroke:#1d4ed8 
```

</div>

> [!NOTE]
> You can view more diagrams in [diagrams.md](./diagrams.md).
# Router Registry

The router [registry](../src/lib/registry.svelte.ts) is a global object that is used to store route
instances and their associated routing configuration.

This registry updates as you navigate through your application and as `<Router />` components
are mounted and unmounted dynamically.

![registry](./assets/registry.png)

## Usage

Though the registry is managed internally, though you can access it to debug your application.

When `<Router />` is mounted, it will register itself in the registry.

When `<Router />` is unmounted, it will unregister itself from the registry.

You can access the __global__ registry to debug your application by adding the following to your application:

```svelte
<script lang="ts">
  import { registry } from "@mateothegreat/svelte5-router";
</script>

<div>
  {#each registry.instances.entries() as [id, instance]}
    <div>
      <pre>id: {id}</pre>
      <pre>routes: {instance.routes.size}</pre>
      <pre>current: {instance.current?.path || "<default>"}</pre>
      <pre>navigating: {instance.navigating ? "yes" : "no"}</pre>
    </div>
  {/each}
</div>
```

Or, you can access the __local__ registry directly from your `<Router />` component:

```svelte
<script lang="ts">
  import type { RouterInstance } from "@mateothegreat/svelte5-router";
  import { Router } from "@mateothegreat/svelte5-router";

  let instance = $state<RouterInstance>();

  $inspect(instance); // Outputs the registry instance to the console.
</script>

<Router bind:instance {routes} />
```
# Routing Patterns

As your application grows, you'll likely need to use more complex routing patterns. This guide will cover the most common patterns and how to use them.
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification
is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>

asdf [^1]

<h1 class="style-me">header</h1>
<p data-toggle="modal">paragraph</p>

[<button>Click me</button>](https://www.google.com)

[[docs/readme]]asdf

## Table of Contents

- [Routing Patterns](#routing-patterns)
  - [Table of Contents](#table-of-contents)
  - [Default Route](#default-route)
  - [Single Path](#single-path)
  - [Nested Paths](#nested-paths)
  - [Parameter Extraction](#parameter-extraction)
  - [Named Parameters](#named-parameters)

## Default Route

This example demonstrates how to make a route be the default route under the following conditions:

Order of operations:

1. If the path is empty, the route will be matched otherwise evaluation will continue.
2. If no other route matches, the default route will be matched and evaluation will continue.
3. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

> [!NOTE]
> You can omit the `path` property to make the route the default route which is the
> same as `path: "/"` and `path: ""`.

```ts
const routes: RouteConfig[] = [
  {
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/",
    component: ComponentToRender 
  }
];
```

## Single Path

This example will match any path that starts with `/path`.

Order of operations:

1. If the path matches exactly, the route will be matched otherwise evaluation will continue.
2. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path",
    component: ComponentToRender 
  }
];
```

## Nested Paths

This example will match any path that starts with `/path/path/path` and can be nested further.

> [!NOTE]
> This example has a demo available at <https://demo.router.svelte.spa/nested>!

Order of operations:

1. If the path matches exactly, the route will be matched otherwise evaluation will continue.
2. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/path",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/path/path",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/path/path/path",
    component: ComponentToRender 
  }
];
```

## Parameter Extraction

Combine arbitrary paths and extractable parameters.

> [!NOTE]
> This example has a demo available at <https://demo.router.svelte.spa/paths-and-params>!

Order of operations:

1. If there are arbitrary paths, the route **must** contain all of them.
2. If there are parameters, the path **must** match the expression.
3. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

**Unnamed Parameters**:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(.*?)/path/(.*?)",
    component: ComponentToRender 
  }
];
```

**Named Parameters**:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(?<myParam>.*)/path/(?<myParam2>.*)",
    component: ComponentToRender 
  }
];
```

## Named Parameters

This example will match any path that starts with `/path/path/path/path` and can be nested further.

Order of operations:

1. If the path matches exactly, the route will be matched otherwise evaluation will continue.
2. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

```ts
const routes: RouteConfig[] = [
  {
    path: "(?<myParam>.*)",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(?<myParam>.*)",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(?<myParam>.*)/path/(?<myParam2>.*)",
    component: ComponentToRender 
  }
];
```

a
[^1]: This is a footnote
b
# Routing Usage

We provide an array of `RouteConfig` objects to the `Router` component.

Each `RouteConfig` object describes a route and its associated component.

## Pattern Matching

You can simply use static paths like `/foo` or dynamic paths like `/foo/(.*?)` with regex.

Example patterns:

| Pattern                                        | Description                                             |
| ---------------------------------------------- | ------------------------------------------------------- |
| `/`                                            | The root path.                                          |
| `/foo`                                         | A static path.                                          |
| `/foo/(.*?)`                                   | A dynamic path.                                         |
| `/cool/(.*?)/(.*?)`                            | A dynamic path with two parameters.                     |
| `(?<param1>.*)`                                | A dynamic path with a named parameter.                  |
| `^/users/(?<id>[a-z0-9]{25})(?:/(?<tab>.*))?$` | A dynamic path with a named parameter and optional tab. |

> When using named parameters, you can access them using the `$props()` function.
>
> For example, if the route is `/users/123/settings`, then `$props()` will be `{ id: "123", tab: "settings" }`.

## Parameter Extraction

Parameters that are capable of being parsed from the path are passed to the component through the `route` prop:

```svelte
<script>
  let { route } = $props();
</script>
```

When using named parameters such as `(?<id>[a-z0-9]{25})`, the parameter value will be passed through the `route` prop as an object:

```ts
const routes: RouteConfig[] = [
  {
    path: "/users/(?<id>[a-z0-9]{25})",
    component: User
  }
];
```

and can be accessed like this:

```svelte
<script>
  const userId = route.result.path.params.id;
</script>
```

For the full shape of `RouteResult` see the [API Reference](https://github.com/mateothegreat/svelte5-router/blob/main/src/lib/route.svelte.ts#L24).

## Examples

### Basic

The following example demonstrates a basic route configuration with two routes:

```ts
const routes: RouteConfig[] = [
  {
    // Notice that we don't need to specify the path.
    // The router will use this route as the default route when "/" is visited.
    component: Home
  },
  {
    path: "/about",
    component: About
  }
];
```

Passing the routes to the `<Router />` component:

```svelte
<Router {routes} />
```

## Full Example

The following example demonstrates a more complex route configuration with multiple routes and hooks:

```ts
const routes: RouteConfig[] = [
  // Example of a route that redirects to the home route:
  {
    path: "",
    hooks: {
      pre: () => {
        goto("/home");
      }
    }
  },
  {
    // Here we use a regex to match the home route.
    // This is useful if you want to match a route that has a dynamic path.
    // The "?:" is used to group the regex without capturing the match:
    path: /(?:^$|home)/,
    component: Home,
    // Use hooks to perform actions before and after the route is resolved:
    hooks: {
      pre: async (route: RouteResult): Promise<boolean> => {
        console.log("pre hook #1 fired for route");
        return true; // Return true to continue down the route evaluation path.
      },
      // Hooks can also be an array of functions (async too):
      post: [
        // This is a post hook that will be executed after the route is resolved:
        (route: RouteResult): boolean => {
          console.log("post hook #1 fired for route");
          return true; // Return true to continue down the route evaluation path.
        },
        // This is an async post hook that will be executed after the route is resolved:
        async (route: RouteResult): Promise<boolean> => {
          console.log("post hook #2 (async) fired for route");
          return true; // Return true to continue down the route evaluation path.
        }
      ]
    }
  },
  {
    path: "nested",
    component: Nested
  },
  {
    path: "async",
    // Routes can also be async functions that return a promise.
    // This is useful if you want to load a component asynchronously aka "lazy loading":
    component: async () => import("./lib/async/async.svelte")
  },
  {
    path: "delayed",
    component: Delayed,
    hooks: {
      pre: async (route: RouteResult): Promise<boolean> => {
        // Simulate a network delay by returning a promise that resolves after a second:
        return new Promise((resolve) =>
          setTimeout(() => {
            resolve(true);
          }, 1000)
        );
      }
    }
  },
  {
    path: "props",
    component: Props
  },
  {
    path: "protected",
    component: Protected
  },
  {
    path: "query-redirect",
    component: QueryRedirect
  },
  {
    path: "context",
    component: Context
  }
];

// This is a global pre hook that can be applied to all routes.
// Here you could check if the user is logged in or perform some other
// authentication checks:
const globalAuthGuardHook = async (route: RouteResult): Promise<boolean> => {
  console.warn("globalAuthGuardHook", route);
  // Return true so that the route can continue down its evaluation path.
  return true;
};
```
# Route Statuses

Each router instance can have a set of statuses that are rendered when a route
returns a specific status code such as 404 for "Not Found".

When a route returns a status code, the router will render the component or execute the function
specified in the `statuses` prop for that status code.

## Status Codes

Using the `StatusesMapping` enum, the following status codes are to be supported:

> [!NOTE]
> Currently, the `404` status code is implemented. We will be adding the
> other status codes in the future.

| Code    | Description           | Status          |
| ------- | --------------------- | --------------- |
| 301     | Permanent Redirect    | Coming Soon     |
| 302     | Temporary Redirect    | Coming Soon     |
| 400     | Bad Request           | Coming Soon     |
| 401     | Unauthorized          | Coming Soon     |
| 403     | Forbidden             | Coming Soon     |
| __404__ | __Not Found__         | __Implemented__ |
| 500     | Internal Server Error | Coming Soon     |

## `BadRouted` Object

When passing a function to the `statuses` value, the [`RouteResult`](../src/lib/route.ts) object is passed to that function.

It contains the following properties:

- `path`: The path that was attempted to be accessed
- `status`: The status code that was returned

## Usage

### Basic Usage

In this example, we will use the `NotFound` component to render when the router
returns a 404 status code because the route `/bad` does not exist.

First, we will create the `NotFound` component:

```svelte
<script lang="ts">
  let props = $props();
</script>

<div class="flex flex-col items-center justify-center gap-4">
  <pre class="rounded-md bg-gray-800 p-2 text-sm text-emerald-500">included from "not-found.svelte":</pre>
  <h1 class="text-2xl font-bold">404 not found :(</h1>
  <p class="text-sm text-gray-500">The page you are looking for does not exist.</p>
  <pre class="rounded-md bg-gray-900 p-2 text-sm text-gray-400">
    $props():
    {JSON.stringify(props, null, 2)}
  </pre>
</div>
```

Next, we will create the `Router` component and pass the `NotFound` component
to the `statuses` prop:

```svelte
<script lang="ts">
  import { Router, Route, StatusCode } from "@mateothegreat/svelte5-router";
  import NotFound from "./lib/not-found.svelte";

  const routes: RouteConfig[] = [
    // add routes here
  ];
</script>

<Router
  {routes}
  statuses={{
    [StatusCode.NotFound]: NotFound
  }} />
```

When you navigate to `/bad`, the `NotFound` component will be rendered because
the route `/bad` does not exist.

### Custom Usage

You can also pass a function to the `statuses` prop to have more control over the rendered component. The function receives a `BadRouted` object containing information about the failed route and must return an object with the component to render and any additional props:

```svelte
<script lang="ts">
  import { Router, type RouteConfig, StatusCode, getStatusByValue } from "@mateothegreat/svelte5-router";
  import NotFound from "./lib/not-found.svelte";

  const routes: RouteConfig[] = [
    // add routes here
  ];
</script>

<Router
  id="my-main-router"
  bind:instance
  {routes}
  statuses={{
     [StatusCode.NotFound]: (route: RouteResult) => {
      console.warn(
        `Route "${route.result.path.original}" could not be found :(`,
        {
          statusName: getStatusByValue(route.result.status),
          statusValue: route.result.status
        },
        route
      );
      return {
        component: NotFound,
        props: {
          somethingExtra: new Date().toISOString()
        }
      };
    }
  }} />
```

In this example, when a 404 error occurs:

1. The function logs a warning with details about the failed route
2. Returns the `NotFound` component with an additional prop `somethingExtra` containing the current timestamp
3. The `NotFound` component will receive both its default props and the extra props specified in the function
# Routing Styling

You can have the router apply a class to the active route by setting the `active.class` option
when configuring your routes.

As the routes change, the router will apply the class to the active route while removing it from the previous active route(s).

## Configuration

This property can be a string or an array of strings:

> [!NOTE]
> This is a convenience feature and is not required. You can apply the class to the active route manually in your component.
>
> See <https://docs.router.svelte.spa/classes/RouteOptions.html> for more information.

Using a string:

```ts
export const myDefaultRouteConfig = {
  active: {
    class: "bg-yellow-500"
  }
};
```

Using an array of strings:

```ts
export const myDefaultRouteConfig = {
  active: {
    class: [
      "bg-yellow-500",
      "underline"
    ]
  }
};
```

## Usage

With our common configuration declared we can use it in our routes:

Import the common configuration:

```ts
<script lang="ts">
  import { myDefaultRouteConfig } from "./lib/common-stuff";
</script>
```

### Using `use:route`

```svelte
<a
  use:route={myDefaultRouteConfig}
  href="/props"
  class="py-1 hover:bg-blue-800 rounded bg-blue-600 px-3">
  /props
</a>
```

### Using `use:active`

You can also be more prescriptive and pass in the active class as an object.

> [!NOTE]
> This is functionally equivalent to using `use:route` with the same configuration.
> It is just a convenience method for when you don't need to pass in any other options.

```svelte
<a
  use:route
  use:active={{ active: { class: "bg-pink-500" } }}
  href="/baz"
  class="py-1 hover:bg-blue-800 rounded bg-blue-600 px-3">
  Click Me
</a>
```

Here we used two actions:

- `use:route`
  - This is the default action and is used to apply the active class to the active route.
- `use:active`
  - This is a convenience action that is used to apply the active class to the active route.
Directory Structure:

└── ./
    ├── .github
    │   └── ISSUE_TEMPLATE
    │       ├── bug_report.md
    │       └── feature_request.md
    ├── demo
    │   ├── cypress
    │   │   ├── e2e
    │   │   │   └── route-activation.cy.ts
    │   │   └── support
    │   │       ├── commands.ts
    │   │       └── e2e.ts
    │   ├── src
    │   │   ├── lib
    │   │   │   ├── components
    │   │   │   │   ├── routes
    │   │   │   │   │   ├── route-link.svelte
    │   │   │   │   │   ├── route-title.svelte
    │   │   │   │   │   └── route-wrapper.svelte
    │   │   │   │   ├── badge.svelte
    │   │   │   │   ├── code.svelte
    │   │   │   │   ├── container.svelte
    │   │   │   │   ├── default.svelte
    │   │   │   │   ├── file-link.svelte
    │   │   │   │   └── inline-code.svelte
    │   │   │   ├── default-route-config.ts
    │   │   │   ├── router-history.ts
    │   │   │   └── session.svelte.ts
    │   │   ├── routes
    │   │   │   ├── extras
    │   │   │   │   ├── dump.svelte
    │   │   │   │   ├── extras.svelte
    │   │   │   │   └── passing-down-props.svelte
    │   │   │   ├── hash
    │   │   │   │   └── hash.svelte
    │   │   │   ├── nested
    │   │   │   │   ├── level-1
    │   │   │   │   │   ├── level-2
    │   │   │   │   │   │   ├── level-3
    │   │   │   │   │   │   │   └── level-3.svelte
    │   │   │   │   │   │   └── level-2.svelte
    │   │   │   │   │   └── level-1.svelte
    │   │   │   │   └── nested.svelte
    │   │   │   ├── paths-and-params
    │   │   │   │   ├── custom-not-found.svelte
    │   │   │   │   ├── display-params.svelte
    │   │   │   │   ├── paths-and-params.svelte
    │   │   │   │   └── querystring-matching.svelte
    │   │   │   ├── patterns
    │   │   │   │   ├── dump.svelte
    │   │   │   │   ├── output.svelte
    │   │   │   │   ├── parameter-extraction.svelte
    │   │   │   │   └── patterns.svelte
    │   │   │   ├── protected
    │   │   │   │   ├── manage-account
    │   │   │   │   │   ├── auth-guard-fast.ts
    │   │   │   │   │   ├── auth-guard-slow.ts
    │   │   │   │   │   ├── balance.svelte
    │   │   │   │   │   ├── home.svelte
    │   │   │   │   │   ├── manage-account.svelte
    │   │   │   │   │   └── worker-client.svelte.ts
    │   │   │   │   ├── account-state.svelte.ts
    │   │   │   │   ├── denied.svelte
    │   │   │   │   ├── login.svelte
    │   │   │   │   └── main.svelte
    │   │   │   ├── transitions
    │   │   │   │   ├── fade.svelte
    │   │   │   │   ├── slide.svelte
    │   │   │   │   └── transitions.svelte
    │   │   │   ├── delayed.svelte
    │   │   │   ├── home.svelte
    │   │   │   └── not-found.svelte
    │   │   ├── app.css
    │   │   ├── app.svelte
    │   │   ├── main.ts
    │   │   └── vite-env.d.ts
    │   ├── cypress.config.ts
    │   ├── index.html
    │   ├── svelte.config.ts
    │   ├── tailwind.config.ts
    │   └── vite.config.ts
    ├── docs
    │   ├── actions.md
    │   ├── changelog.md
    │   ├── debugging.md
    │   ├── getting-started.md
    │   ├── helpers.md
    │   ├── hooks.md
    │   ├── props.md
    │   ├── readme.md
    │   ├── registry.md
    │   ├── routing-patterns.md
    │   ├── routing.md
    │   ├── statuses.md
    │   └── styling.md
    ├── src
    │   ├── lib
    │   │   ├── actions
    │   │   │   ├── active.svelte.ts
    │   │   │   ├── apply-classes.ts
    │   │   │   ├── index.ts
    │   │   │   ├── options.ts
    │   │   │   └── route.svelte.ts
    │   │   ├── helpers
    │   │   │   ├── evaluators.test.ts
    │   │   │   ├── evaluators.ts
    │   │   │   ├── goto.ts
    │   │   │   ├── identify.ts
    │   │   │   ├── index.ts
    │   │   │   ├── logging.ts
    │   │   │   ├── marshal.test.ts
    │   │   │   ├── marshal.ts
    │   │   │   ├── normalize.ts
    │   │   │   ├── objects.ts
    │   │   │   ├── query.ts
    │   │   │   ├── regexp.ts
    │   │   │   ├── runtime.ts
    │   │   │   ├── tracing.svelte.ts
    │   │   │   ├── urls.test.ts
    │   │   │   └── urls.ts
    │   │   ├── hash.test.ts
    │   │   ├── hash.ts
    │   │   ├── hooks.ts
    │   │   ├── index.ts
    │   │   ├── path.ts
    │   │   ├── query.svelte.ts
    │   │   ├── query.test.ts
    │   │   ├── registry.svelte.ts
    │   │   ├── route.svelte.ts
    │   │   ├── router-instance-config.ts
    │   │   ├── router-instance.svelte.ts
    │   │   ├── router.svelte
    │   │   ├── statuses.ts
    │   │   └── utilities.svelte.ts
    │   └── vite-env.d.ts
    ├── svelte.config.ts
    ├── vite.config.ts
    ├── vitest.config.ts
    └── vitest.setup.ts



---
File: /.github/ISSUE_TEMPLATE/bug_report.md
---

---
name: Bug report
about: Create a report to help us improve
title: ''
labels: bug
assignees: mateothegreat

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Logs**
If available please provide any available logs, screenshots, etc.

**Additional context**
Add any other context about the problem here.



---
File: /.github/ISSUE_TEMPLATE/feature_request.md
---

---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: enhancement
assignees: mateothegreat

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Additional context**
Add any other context or screenshots about the feature request here.



---
File: /demo/cypress/e2e/route-activation.cy.ts
---

/// <reference types="cypress" />

const routes = require("../fixtures/routes.json");
describe.only("route activation", () => {
  beforeEach(() => {
    cy.viewport(1500, 1500);
    cy.visit("http://localhost:8173");
  });

  routes.forEach((route) => {
    it(`should activate ${route.id} when visiting ${route.path}`, () => {
      cy.clickAndValidateActiveClasses(`a[href='${route.path}']`, "active", route.active);
    });
  });

  // it.only("displays two todo items by default", () => {
  //   // cy.get("a[href='/props']").should("have.length", 1).click();
  //   // cy.contains("props.svelte").should("exist");

  //   // cy.get("a[href='/props/foo']").should("have.length", 1).click();
  //   // cy.contains("display-params.svelte").should("exist");
  //   // cy.contains(`"child": "foo"`).should("exist");

  //   // cy.get("a").filter('[href^="/props/bar?"]').should("have.length", 1).click();
  //   // cy.contains("display-params.svelte").should("exist");
  //   // cy.contains(`"child": "bar"`).should("exist");

  //   // cy.get("a").filter('[href="/props/foo"]').should("not.have.class", "active");
  //   // cy.get("a").filter('[href^="/props/bar"]').should("have.class", "active");

  //   cy.clickAndValidateActiveClasses("a[href='/props']", "active");
  // });

  // it("can add new todo items", () => {
  //   // We'll store our item text in a variable so we can reuse it
  //   const newItem = "Feed the cat";

  //   // Let's get the input element and use the `type` command to
  //   // input our new list item. After typing the content of our item,
  //   // we need to type the enter key as well in order to submit the input.
  //   // This input has a data-test attribute so we'll use that to select the
  //   // element in accordance with best practices:
  //   // https://on.cypress.io/selecting-elements
  //   cy.get("[data-test=new-todo]").type(`${newItem}{enter}`);

  //   // Now that we've typed our new item, let's check that it actually was added to the list.
  //   // Since it's the newest item, it should exist as the last element in the list.
  //   // In addition, with the two default items, we should have a total of 3 elements in the list.
  //   // Since assertions yield the element that was asserted on,
  //   // we can chain both of these assertions together into a single statement.
  //   cy.get(".todo-list li")
  //     .should("have.length", 3)
  //     .last()
  //     .should("have.text", newItem);
  // });

  // it("can check off an item as completed", () => {
  //   // In addition to using the `get` command to get an element by selector,
  //   // we can also use the `contains` command to get an element by its contents.
  //   // However, this will yield the <label>, which is lowest-level element that contains the text.
  //   // In order to check the item, we'll find the <input> element for this <label>
  //   // by traversing up the dom to the parent element. From there, we can `find`
  //   // the child checkbox <input> element and use the `check` command to check it.
  //   cy.contains("Pay electric bill")
  //     .parent()
  //     .find("input[type=checkbox]")
  //     .check();

  //   // Now that we've checked the button, we can go ahead and make sure
  //   // that the list element is now marked as completed.
  //   // Again we'll use `contains` to find the <label> element and then use the `parents` command
  //   // to traverse multiple levels up the dom until we find the corresponding <li> element.
  //   // Once we get that element, we can assert that it has the completed class.
  //   cy.contains("Pay electric bill")
  //     .parents("li")
  //     .should("have.class", "completed");
  // });

  // context("with a checked task", () => {
  //   beforeEach(() => {
  //     // We'll take the command we used above to check off an element
  //     // Since we want to perform multiple tests that start with checking
  //     // one element, we put it in the beforeEach hook
  //     // so that it runs at the start of every test.
  //     cy.contains("Pay electric bill")
  //       .parent()
  //       .find("input[type=checkbox]")
  //       .check();
  //   });

  //   it("can filter for uncompleted tasks", () => {
  //     // We'll click on the "active" button in order to
  //     // display only incomplete items
  //     cy.contains("Active").click();

  //     // After filtering, we can assert that there is only the one
  //     // incomplete item in the list.
  //     cy.get(".todo-list li")
  //       .should("have.length", 1)
  //       .first()
  //       .should("have.text", "Walk the dog");

  //     // For good measure, let's also assert that the task we checked off
  //     // does not exist on the page.
  //     cy.contains("Pay electric bill").should("not.exist");
  //   });

  //   it("can filter for completed tasks", () => {
  //     // We can perform similar steps as the test above to ensure
  //     // that only completed tasks are shown
  //     cy.contains("Completed").click();

  //     cy.get(".todo-list li")
  //       .should("have.length", 1)
  //       .first()
  //       .should("have.text", "Pay electric bill");

  //     cy.contains("Walk the dog").should("not.exist");
  //   });

  //   it("can delete all completed tasks", () => {
  //     // First, let's click the "Clear completed" button
  //     // `contains` is actually serving two purposes here.
  //     // First, it's ensuring that the button exists within the dom.
  //     // This button only appears when at least one task is checked
  //     // so this command is implicitly verifying that it does exist.
  //     // Second, it selects the button so we can click it.
  //     cy.contains("Clear completed").click();

  //     // Then we can make sure that there is only one element
  //     // in the list and our element does not exist
  //     cy.get(".todo-list li")
  //       .should("have.length", 1)
  //       .should("not.have.text", "Pay electric bill");

  //     // Finally, make sure that the clear button no longer exists.
  //     cy.contains("Clear completed").should("not.exist");
  //   });
  // });
});



---
File: /demo/cypress/support/commands.ts
---

/// <reference types="cypress" />



---
File: /demo/cypress/support/e2e.ts
---

import "./commands";

declare global {
  namespace Cypress {
    interface Chainable {
      /**
       * Custom command to check if navigation link is active based on href.
       *
       * @param selector - The selector to check against
       * @param attribute - The attribute to check against
       * @param value - The value to check against
       *
       * @example cy.hasClassByAttr('nav a', 'href', '/about', 'foo')
       */
      allowedClassesByAttr(selector: string, attribute: string, allowed: string | string[], className: string): Chainable<Element>;

      /**
       * Custom command to navigate to a specific path and validate the number of active elements.
       *
       * @param selector - The selector to check against
       * @param path - The path to navigate to
       * @param expected - The expected number of active elements
       *
       * @example cy.clickAndValidateActiveClasses("a[href='/props/foo']", "active", 1)
       */
      clickAndValidateActiveClasses(selector: string, path: string, expected: number): Chainable<Element>;
    }
  }
}

Cypress.Commands.add("allowedClassesByAttr", (selector: string, attribute: string, allowed: string | string[], className: string) => {
  cy.get(selector).then(($elements) => {
    $elements.each((_, $el) => {
      cy.wrap($el).then(($el) => {
        if ($el.attr(attribute) !== allowed && $el.hasClass(className)) {
          if (Array.isArray(allowed) && !allowed.includes($el.attr(attribute) || "")) {
            throw new Error(`allowedClassesByAttr: ${attribute}="${$el.attr(attribute)}" has class "${className}" (allowed: "${allowed}")`);
          } else if ($el.attr(attribute) !== allowed && $el.hasClass(className)) {
            throw new Error(`allowedClassesByAttr: ${attribute}="${$el.attr(attribute)}" has class "${className}" (allowed: "${allowed}")`);
          }
        }
      });
    });
  });
});

Cypress.Commands.add("clickAndValidateActiveClasses", (selector: string, className: string, expected: number) => {
  cy.get(selector).then(($el) => {
    if ($el.length !== 1) {
      throw new Error(`clickAndValidateActiveClasses: ${selector} should match only 1 element, has ${$el.length}`);
    }
    cy.get(selector).click();
    cy.allowedClassesByAttr("nav a", "href", $el.attr("href") || "", className);
  });
});



---
File: /demo/src/lib/components/routes/route-link.svelte
---

<script lang="ts">
  import { session } from "$lib/session.svelte";
  import { route, RouteOptions } from "@mateothegreat/svelte5-router";

  export type RouteLinkProps = {
    options?: RouteOptions;
    href: string;
    label: string;
  };

  let { options, href, label }: RouteLinkProps = $props();
  if (!options) {
    options = new RouteOptions();
  }

  if (!options.active) {
    options.active = {
      class: ["active", "bg-indigo-600", "text-white", "border-indigo-400"]
    };
  }
  if (!options.default) {
    options.default = {
      class: ["inactive", "text-slate-300", "border-slate-500/50"]
    };
  }
  if (!options.loading) {
    options.loading = {
      class: ["loading", "bg-orange-500"]
    };
  }
  if (!options.disabled) {
    options.disabled = {
      class: ["disabled", "bg-gray-500"]
    };
  }

  if (!options.active.class) {
    options.active.class = ["active", "bg-indigo-600", "text-white", "border-indigo-400"];
  }

  if (!options.default.class) {
    options.default.class = ["inactive", "text-slate-300", "border-slate-500/50"];
  }
  if (!options.loading.class) {
    options.loading.class = ["loading", "bg-orange-500"];
  }
  if (!options.disabled.class) {
    options.disabled.class = ["disabled", "bg-gray-500"];
  }
</script>

<a
  use:route={options}
  href={session.mode === "hash" ? `/#${href}` : href}
  class="duration-400 flex items-center rounded-sm border-2 px-2.5 py-0.5 text-sm transition-all hover:border-green-300 hover:bg-green-600 hover:text-white">
  {#if session.mode === "hash"}
    <span>/#</span>
    <span>/{label.startsWith("/") ? label.slice(1) : label}</span>
  {:else}
    <span>
      {label}
    </span>
  {/if}
</a>



---
File: /demo/src/lib/components/routes/route-title.svelte
---

<script lang="ts">
  import type { RouteResult, RouterInstance } from "@mateothegreat/svelte5-router";
  import { ArrowDown, ArrowRight, ArrowRightFromLine, StopCircle } from "lucide-svelte";
  import FileLink from "../file-link.svelte";

  export type RouteTitleProps = {
    router?: RouterInstance;
    route?: RouteResult;
    file?: string;
    content?: any;
    end?: boolean;
  };

  let { router = $bindable(), route, file, content, end }: RouteTitleProps = $props();
</script>

<div class="flex flex-col gap-4">
  <div class="flex items-center gap-3 rounded-md bg-black/50 p-1.5 px-2 border-2">
    {#if router}
      <div class="flex flex-wrap items-center rounded-sm bg-gray-800 px-1.5 py-0.5 text-sm text-slate-500">
        <ArrowRightFromLine class="h-4 w-4 text-green-400 mr-1" />
        {router.config.id}
        {#if router.navigating}
          <span class="px-1 py-0.5 text-red-400">(hooks firing)</span>
        {:else}
          <span class="px-1 py-0.5 text-slate-600">(idle)</span>
        {/if}
        routed the path
        <span class="px-1 py-0.5 text-green-400">
          {route?.absolute?.()}
        </span>
        and nesting&nbsp;
        {#if end}
          <span class="flex items-center gap-1 whitespace-nowrap">
            <span class="text-red-400">stopped</span>
            <StopCircle class="h-4 w-4 text-red-400" />
          </span>
        {:else}
          <span class="flex items-center gap-1 whitespace-nowrap">
            <span class="text-green-400">continued</span>
            <ArrowDown class="h-4 w-4 text-green-400" />
          </span>
        {/if}
      </div>
    {/if}
    <ArrowRight class="h-4 w-4 text-slate-500" />
    <FileLink {file} />
  </div>
  {#if content}
    <div class="p-2">
      {#if typeof content === "string"}
        <div class="flex flex-col items-center gap-2 text-center text-slate-400">
          <div class="max-w-3xl text-sm text-slate-500">
            {content}
          </div>
        </div>
      {:else}
        <div class="flex items-center">
          {@render content()}
        </div>
      {/if}
    </div>
  {/if}
</div>



---
File: /demo/src/lib/components/routes/route-wrapper.svelte
---

<script lang="ts">
  import type { RouteResult, RouterInstance } from "@mateothegreat/svelte5-router";
  import { Anchor } from "lucide-svelte";
  import type { RouteLinkProps } from "./route-link.svelte";
  import RouteLink from "./route-link.svelte";
  import type { RouteTitleProps } from "./route-title.svelte";
  import RouteTitle from "./route-title.svelte";

  export type RouteWrapperProps = {
    router?: RouterInstance;
    name: string;
    route?: RouteResult;
    end?: boolean;
    title: RouteTitleProps;
    links: RouteLinkProps[];
    children?: any;
  };

  let { router = $bindable(), name, route, title, links, children, end = $bindable() }: RouteWrapperProps = $props();
</script>

<div class="flex flex-col gap-3 border-2 rounded-md h-full p-2.5">
  <div class="flex flex-col gap-4">
    <RouteTitle
      {router}
      {route}
      {end}
      file={title.file}
      content={title.content} />
    <div class="flex w-fit items-center gap-2 rounded-md border-2 border-slate-900/80 bg-slate-700/80 p-1.5">
      <p class="flex items-center gap-1 text-sm text-slate-300">
        <Anchor class="h-4 w-4 text-indigo-500" />
        <span class="text-pink-400">{router?.config.id}</span>
        routes:
      </p>
      {#each links as link}
        <RouteLink {...link} />
      {/each}
    </div>
  </div>
  <div class="flex-1">
    {@render children?.()}
  </div>
</div>



---
File: /demo/src/lib/components/badge.svelte
---

<script lang="ts">
  import { AlertTriangleIcon, CheckCircleIcon, InfoIcon, XCircleIcon } from "lucide-svelte";
  import type { Snippet } from "svelte";

  let {
    icon,
    text,
    variant = "info",
    class: className,
    children
  }: {
    icon?: any;
    text?: string;
    variant?: "info" | "success" | "warning" | "error";
    class?: string;
    children?: Snippet;
  } = $props();

  const variants = {
    info: {
      classes: "bg-blue-900 text-white",
      icon: InfoIcon
    },
    success: {
      classes: "bg-green-600/80 text-white",
      icon: CheckCircleIcon
    },
    warning: {
      classes: "bg-yellow-200/80 text-black",
      icon: AlertTriangleIcon
    },
    error: {
      classes: "bg-red-900/80 text-white",
      icon: XCircleIcon
    }
  };

  let Icon = icon ?? variants[variant].icon;
</script>

<span
  class="inline-flex items-center gap-1.5 rounded-sm p-2 text-sm font-medium {variants[variant].classes} {className}">
  {#if Icon}
    <Icon class="inline-block h-5 w-5" />
  {/if}
  {text}
  {@render children?.()}
</span>



---
File: /demo/src/lib/components/code.svelte
---

<script lang="ts">
  import { transformerColorizedBrackets } from "@shikijs/colorized-brackets";
  import { Code2 } from "lucide-svelte";
  import { createHighlighter, type Highlighter } from "shiki";
  import { onMount, type Snippet } from "svelte";
  import FileLink from "./file-link.svelte";

  let {
    title,
    file,
    class: className,
    children,
    language = "typescript",
    theme = "github-dark-dimmed"
  }: {
    title?: string;
    file?: string;
    class?: string;
    children?: Snippet;
    language?: string;
    theme?: string;
  } = $props();

  // State for the highlighted HTML content
  let highlightedContent = $state<string>("");
  // State for the reference to the hidden temporary element
  let tempElement: HTMLElement | undefined = $state(undefined);
  // State for the Shiki highlighter instance
  let shikiHighlighter: Highlighter | null = $state(null);

  /**
   * Initializes the Shiki highlighter instance once when the component mounts.
   */
  onMount(async () => {
    shikiHighlighter = await createHighlighter({
      themes: [theme],
      langs: ["typescript", "svelte", "html", "css", "json"]
    });
  });

  /**
   * Reactive effect that updates the syntax highlighting whenever
   * the children, language, or highlighter instance changes.
   */
  $effect(() => {
    if (!shikiHighlighter || !children || !tempElement) {
      if (!children) {
        highlightedContent = "";
      }
      return;
    }

    /**
     * At this point, Svelte has rendered the output of `children()` into `tempElement`
     * due to the `{@render children()}` directive in the hidden div.
     * We can now extract the raw text content from it.
     */
    const codeContent = (tempElement.textContent || "").trim();

    if (codeContent) {
      try {
        // Convert the raw code string to HTML using Shiki.
        highlightedContent = shikiHighlighter.codeToHtml(codeContent, {
          lang: language,
          theme: theme,
          transformers: [transformerColorizedBrackets()]
        });
      } catch (error) {
        console.error("Shiki highlighting error:", error, { language, codeContent });
        // Fallback to showing raw code (escaped) if highlighting fails.
        highlightedContent = `<pre class="shiki-fallback"><code>${escapeHtml(codeContent)}</code></pre>`;
      }
    } else {
      // Clear highlighted content if there's no text content.
      highlightedContent = "";
    }
  });

  /**
   * Helper function to escape HTML special characters.
   * Used for the fallback when Shiki highlighting fails.
   */
  function escapeHtml(unsafe: string): string {
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }
</script>

<div class="code-block-container flex flex-col rounded-md border-2 border-slate-700 bg-black/80 {className}">
  <div class="header flex items-center justify-between bg-zinc-900/70 text-sm p-1.5 px-3 flex-shrink-0">
    <p class="flex items-center gap-1.5 font-mono text-xs text-slate-300">
      <Code2 class="h-4 w-4 text-orange-500 shrink-0" />
      {#if title}
        <span>{title}</span>
      {:else}
        <span>Code</span>
      {/if}
    </p>
    {#if file}
      <FileLink {file} />
    {/if}
  </div>

  <!--
    Temporary hidden element.
    The `children` snippet is rendered here by Svelte using `{@render children()}`.
    This component's `$effect` then reads `tempElement.textContent` to get the
    raw string representation of the rendered children for Shiki to process.
  -->
  <div
    bind:this={tempElement}
    style="display: none;"
    aria-hidden="true">
    {#if children}
      {@render children()}
    {/if}
  </div>

  {#if highlightedContent}
    <div class="p-2.5 text-[13px] leading-[18px] overflow-auto bg-[#0a0a0a] flex-1 min-h-0">
      {@html highlightedContent}
    </div>
  {:else if children}
    <pre class="fallback-pre p-3 font-mono text-sm text-slate-200 overflow-auto flex-1 min-h-0">
      {@render children()}
    </pre>
  {:else}
    <div class="p-3 text-slate-500 text-sm font-mono">Loading syntax highlighter...</div>
  {/if}
</div>

<style>
  :global(.shiki) {
    background: #090909 !important;
  }
</style>



---
File: /demo/src/lib/components/container.svelte
---

<script lang="ts">
  import FileLink from "./file-link.svelte";

  let { title, file, children }: { title?: string; file?: string; children: any } = $props();
</script>

<div class="flex flex-col gap-1 rounded-md border-2 border-slate-700 bg-gray-900 text-slate-400">
  <div class="flex items-center justify-between bg-slate-800 p-2 text-sm text-slate-500">
    <p class="flex items-center gap-2 font-mono">
      {#if title}
        &lt;{title} /&gt;
      {/if}
    </p>
    {#if file}
      <FileLink {file} />
    {/if}
  </div>
  {@render children()}
</div>



---
File: /demo/src/lib/components/default.svelte
---

<script lang="ts">
  import { BadgeInfo } from "lucide-svelte";
  import type { Snippet } from "svelte";
  import Badge from "./badge.svelte";

  let { class: className, children }: { class?: string; children?: Snippet } = $props();
</script>

<div class="flex flex-col gap-4 rounded-md border-4 border-slate-900/80 p-4 text-center text-gray-400 {className}">
  {#if children}
    {@render children()}
  {:else}
    <p>
      <Badge
        variant="info"
        icon={BadgeInfo}>
        There was no path provided to the router, so the default route was used (declared as a snippet).
      </Badge>
    </p>
    Click on a link above to see the different effects!
  {/if}
</div>



---
File: /demo/src/lib/components/file-link.svelte
---

<script lang="ts">
  import { FileCode2, GithubIcon } from "lucide-svelte";

  let { file } = $props();
</script>

<div class="flex gap-1">
  <div class="flex flex-1 items-center text-slate-500">
    <FileCode2 class="h-4 w-4" />
  </div>
  <a
    href={`https://github.com/mateothegreat/svelte5-router/blob/main/demo/${file}`}
    class="flex cursor-pointer items-center gap-1 text-center text-sm text-orange-400 hover:font-medium hover:text-indigo-400">
    {file}
  </a>
  <a
    href={`https://github.com/mateothegreat/svelte5-router/blob/main/demo/${file}`}
    target="_blank"
    class="flex cursor-pointer items-center gap-1 text-center text-sm text-slate-500 hover:font-medium hover:text-indigo-400">
    view source
    <GithubIcon class="h-4 w-4" />
  </a>
</div>



---
File: /demo/src/lib/components/inline-code.svelte
---

<script lang="ts">
  export type InlineCodeProps = {
    text: string;
    class?: string;
  };

  let { text, class: className }: InlineCodeProps = $props();

  if (!className) {
    className = "text-green-400 bg-black/50";
  }
</script>

<span class="whitespace-nowrap rounded-md p-1 px-2 font-mono text-sm {className}">{text}</span>



---
File: /demo/src/lib/default-route-config.ts
---

import { StatusCode, type RouteResult } from "@mateothegreat/svelte5-router";

import NotFound from "$routes/not-found.svelte";

/**
 * Surface a reusable configuration for routers to import
 * and apply to their router instances:
 *
 * @example
 * ```ts
 * <script lang="ts">
 *   import { RouteConfig } from "@mateothegreat/svelte5-router";
 *   import { myDefaultRouterConfig } from "$lib/default-route-config";
 *
 *   const routes: RouteConfig[] = [
 *     {
 *       path: "/home",
 *       component: Home
 *     }
 *   ];
 * </script>
 *
 * <Router
 *   id="my-main-router"
 *   {routes}
 *   {...myDefaultRouterConfig} />
 * ```
 */
export const myDefaultRouterConfig = {
  statuses: {
    /**
     * You can use a function to return a new route or a promise that
     * resolves to a new route:
     */
    [StatusCode.NotFound]: (result: RouteResult) => {
      console.log(result);
      return {
        component: NotFound,
        props: {
          somethingExtra: new Date().toISOString()
        }
      };
    }
    /**
     * You can also use an object to return a new route while having access
     * to the path and querystring:
     *
     * [StatusCode.NotFound]: (path: RouteResult) => ({
     *   component: NotFound,
     *   props: {
     *     somethingExtra: new Date().toISOString()
     *   }
     * }),
     *
     *
     * or simply return an object with a component and props:
     *
     * [StatusCode.NotFound]: {
     *   component: NotFound,
     *   props: {
     *     somethingExtra: new Date().toISOString()
     *   }
     * }
     */
  }
};



---
File: /demo/src/lib/router-history.ts
---

import type { Route } from "@mateothegreat/svelte5-router";

export const history = $state<Route[]>([]);

export const appendHistory = (route: Route) => {
  history.push(route);
};



---
File: /demo/src/lib/session.svelte.ts
---

let _state: {
  mode: "hash" | "path";
} = $state({
  mode: (localStorage.getItem("mode") as "hash" | "path") || "path"
});

export const session = {
  set mode(value: "hash" | "path") {
    localStorage.setItem("mode", value);
    _state = {
      ..._state,
      mode: value
    };
    if (value === "hash") {
      window.history.pushState({}, "", `/#/`);
    } else {
      window.history.pushState({}, "", "/");
    }
  },
  get mode() {
    return _state.mode;
  }
};



---
File: /demo/src/routes/extras/dump.svelte
---

<script lang="ts">
  import Code from "$lib/components/code.svelte";
  let { route, ...rest } = $props();
</script>

<div class="flex flex-col gap-3">
  <Code
    title="usage:"
    file="src/routes/extras/dump.svelte"
    class="flex-1">
    {`<script lang="ts">
  let { route, ...rest } = $props();
  console.log(route, rest);
</script>`}
  </Code>

  <div class="flex gap-3">
    <Code
      title="$props().route"
      language="json"
      class="flex-1">
      <div>{JSON.stringify(route, null, 2)}</div>
    </Code>

    <Code
      title="$props().rest"
      language="json"
      class="flex-1">
      <div>{JSON.stringify(rest, null, 2)}</div>
    </Code>
  </div>
</div>



---
File: /demo/src/routes/extras/extras.svelte
---

<script lang="ts">
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { RouterInstance } from "@mateothegreat/svelte5-router";
  import type { RouteConfig } from "@mateothegreat/svelte5-router/route.svelte";
  import Router from "@mateothegreat/svelte5-router/router.svelte";
  import { onDestroy } from "svelte";
  import PassingDownProps from "./passing-down-props.svelte";

  let router: RouterInstance = $state();
  let { route } = $props();

  let randoms = $state({
    float: (Math.random() * 1000).toFixed(2),
    int: (Math.random() * 1000).toFixed(0),
    string: (Math.random() * 1000).toFixed(2).toString()
  });

  const interval = setInterval(() => {
    randoms.float = (Math.random() * 1000).toFixed(2);
    randoms.int = (Math.random() * 1000).toFixed(0);
    randoms.string = (Math.random() * 1000).toFixed(2).toString();
  }, 750);

  onDestroy(() => {
    clearInterval(interval);
  });

  const routes: RouteConfig[] = [
    {
      component: overview
    },
    {
      path: "passing-down-props",
      component: PassingDownProps,
      props: {
        route: "passing-down-props"
      },
      hooks: {
        pre: () => {
          console.log("pre");
          return true;
        }
      }
    }
  ];
</script>

{#snippet overview()}
  <div class="p-2">
    <div class="flex flex-col items-center gap-2 text-center text-slate-400">
      <div class="flex max-w-3xl flex-col gap-2 text-sm text-slate-500">
        <p class="text-fuchsia-500">Extra & cool stuff can be demoed here.</p>
        <p>Click a route above to see the different effects!</p>
      </div>
    </div>
  </div>
{/snippet}

<RouteWrapper
  {router}
  name="extras"
  {route}
  title={{
    file: "src/routes/extras/extras.svelte"
  }}
  links={[
    {
      href: "/extras/passing-down-props",
      label: "passing-down-props"
    }
  ]}>
  <Router
    basePath="/extras"
    bind:instance={router}
    {routes} />
</RouteWrapper>



---
File: /demo/src/routes/extras/passing-down-props.svelte
---

<script lang="ts">
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { RouterInstance } from "@mateothegreat/svelte5-router";
  import type { RouteConfig } from "@mateothegreat/svelte5-router/route.svelte";
  import Router from "@mateothegreat/svelte5-router/router.svelte";
  import Dump from "./dump.svelte";

  let router: RouterInstance = $state();
  let { route } = $props();

  const routes: RouteConfig[] = [
    {
      component: Dump,
      props: {
        foo: "bar",
        baz: {
          awesome: true
        }
      }
    }
  ];
</script>

<RouteWrapper
  {router}
  name="passing-down-props"
  {route}
  end={true}
  title={{
    file: "src/routes/extras/passing-down-props.svelte"
  }}
  links={[
    {
      href: "/extras/passing-down-props",
      label: "default path"
    }
  ]}>
  <Router
    basePath="/extras/passing-down-props"
    bind:instance={router}
    myAdditionalProp="I was added to the <Router/> component directly."
    {routes} />
</RouteWrapper>



---
File: /demo/src/routes/hash/hash.svelte
---

<script lang="ts">
  import { route } from "@mateothegreat/svelte5-router";

  console.log(location.hash);
</script>

<a
  use:route
  href="/hash/#b?test=4">
  b
</a>

<a
  use:route
  href="/hash/#a?test=123">
  a
</a>



---
File: /demo/src/routes/nested/level-1/level-2/level-3/level-3.svelte
---

<script>
  import Container from "$lib/components/container.svelte";
</script>

<Container
  title={"Level_3"}
  file="src/routes/nested/level-1/level-2/level-3/level-3.svelte">
  <div class="flex flex-col gap-3 bg-green-500 p-4 text-center font-medium text-white">
    You've reached the deepest level of nested routing (level-3)!
  </div>
</Container>



---
File: /demo/src/routes/nested/level-1/level-2/level-2.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { Router, RouterInstance, type Route } from "@mateothegreat/svelte5-router";
  import Level_3 from "./level-3/level-3.svelte";

  const routes: Route[] = [
    {
      path: "level-3",
      component: Level_3,
      hooks: {
        pre: () => {
          console.log(`Route "/nested/level-1/level-2" matched (I'm a pre hook in the level-2.svelte route)`);
          return true;
        }
      }
    },
    {
      component: snippet
    }
  ];

  let router: RouterInstance = $state();
  let { route } = $props();
</script>

{#snippet snippet()}
  <Container
    title={"{#snippet snippet()}"}
    file="src/routes/nested/level-1/level-2/level-2.svelte">
    <div class="flex flex-col items-center gap-6 p-10 text-center">
      <Badge>There was no path provided to the router, so the default route was used (declared as a snippet).</Badge>
      Click on a link above to see the different effects!
    </div>
  </Container>
{/snippet}

<RouteWrapper
  {router}
  name="/nested/level-2"
  end={true}
  {route}
  title={{
    file: "src/routes/nested/level-1/level-2/level-2.svelte",
    content:
      "This demo shows how to use nested routing with the router where multiple routers can be nested within each other."
  }}
  links={[
    {
      href: "/nested/level-1/level-2",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/nested/level-1/level-2/level-3",
      label: "/nested/level-1/level-2/level-3"
    }
  ]}>
  <Router
    id="nested-level-2-router"
    basePath="/nested/level-1/level-2"
    bind:instance={router}
    {routes}
    {...myDefaultRouterConfig} />
</RouteWrapper>



---
File: /demo/src/routes/nested/level-1/level-1.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { Router, RouterInstance } from "@mateothegreat/svelte5-router";
  import Level_2 from "./level-2/level-2.svelte";

  let router: RouterInstance = $state();
  let { route, foo } = $props();

  /**
   * Demonstrate how support for additional props is working.
   */
  console.log("additionalProps.foo in ../nested.svelte is passed to this component as:", foo);

  /**
   * This is a helper state variable that can be used to determine if the
   * current route is the same as the route that is being rendered so
   * that we can show a badge to indicate this is the last router in the
   * nested routing hierarchy.
   */
  let end = $state(false);
  $effect(() => {
    end = router.current?.result.path.condition === "default-match";
  });
</script>

{#snippet snippet()}
  <Container
    title={"{#snippet snippet()}"}
    file="src/routes/nested/level-1/level-1.svelte">
    <div class="flex flex-col items-center gap-6 p-10 text-center">
      <Badge>There was no path provided to the router, so the default route was used (declared as a snippet).</Badge>
      Click on a link above to see the different effects!
    </div>
  </Container>
{/snippet}

<RouteWrapper
  {router}
  name="/nested/level-1"
  {end}
  {route}
  title={{
    file: "src/routes/nested/level-1/level-1.svelte",
    content:
      "This demo shows how to use nested routing with the router where multiple routers can be nested within each other."
  }}
  links={[
    {
      href: "/nested/level-1",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/nested/level-1/level-2",
      label: "/nested/level-1/level-2"
    }
  ]}>
  <Router
    id="nested-level-1-router"
    basePath="/nested/level-1"
    bind:instance={router}
    routes={[
      {
        path: "level-2",
        component: Level_2,
        hooks: {
          pre: () => {
            console.log(`Route "/nested/level-1/level-2" matched (I'm a pre hook in the level-1.svelte route)`);
            return true;
          }
        }
      },
      /**
       * Default routes can be placed anywhere in the routes array
       * and will be matched if no other routes match regardless of
       * their position in the array:
       */
      {
        component: snippet
      }
    ]}
    {...myDefaultRouterConfig} />
</RouteWrapper>



---
File: /demo/src/routes/nested/nested.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { Router, RouterInstance, type Route } from "@mateothegreat/svelte5-router";
  import Level_1 from "./level-1/level-1.svelte";

  const routes: Route[] = [
    {
      component: snippet
    },
    {
      path: "level-1",
      component: Level_1,
      hooks: {
        pre: () => {
          console.log(`Route "/nested/level-1" matched (I'm a pre hook in the nested.svelte route)`);
          return true;
        }
      }
    }
  ];

  let router: RouterInstance = $state();
  let { route } = $props();

  /**
   * This is a helper state variable that can be used to determine if the
   * current route is the same as the route that is being rendered so
   * that we can show a badge to indicate this is the last router in the
   * nested routing hierarchy.
   */
  let end = $state(false);
  $effect(() => {
    end = router.current?.result.path.condition === "default-match";
  });

  const additionalProps = {
    foo: {
      bar: "baz"
    }
  };
</script>

{#snippet snippet()}
  <Container
    title={"{#snippet snippet()}"}
    file="src/routes/nested/nested.svelte">
    <div class="flex flex-col items-center gap-6 p-10 text-center">
      <Badge>There was no path provided to the router, so the default route was used (declared as a snippet).</Badge>
      Click on a link above to see the different effects!
    </div>
  </Container>
{/snippet}

<RouteWrapper
  {router}
  name="/nested"
  {route}
  {end}
  title={{
    file: "src/routes/nested/nested.svelte",
    content:
      "This demo shows how to use nested routing with the router where multiple routers can be nested within each other."
  }}
  links={[
    {
      href: "/nested",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/nested/level-1",
      label: "/nested/level-1"
    }
  ]}>
  <Router
    id="nested-router"
    basePath="/nested"
    bind:instance={router}
    {...myDefaultRouterConfig}
    {routes}
    {...additionalProps} />
</RouteWrapper>



---
File: /demo/src/routes/paths-and-params/custom-not-found.svelte
---

<script lang="ts">
  let { route } = $props();
</script>

<div class="flex flex-col items-center justify-center gap-4">
  <pre class="rounded-md bg-gray-800 p-2 text-sm text-emerald-500">included from "custom-not-found.svelte":</pre>
  <h1 class="text-2xl font-bold">404 not found :(</h1>
  <p class="text-sm text-gray-500">The page you are looking for does not exist.</p>
  <pre class="rounded-md bg-gray-900 p-2 text-sm text-gray-400">$props():

{JSON.stringify(route, null, 2)}
</pre>
</div>



---
File: /demo/src/routes/paths-and-params/display-params.svelte
---

<script lang="ts">
  import Code from "$lib/components/code.svelte";
  import InlineCode from "$lib/components/inline-code.svelte";

  let { route } = $props();
</script>

{#snippet content()}
  The route uses the pattern <InlineCode text="/\/?<child>.*)/" /> which captures everything after the base path and passes
  it to the component as the `params` prop.
{/snippet}

<Code
  title="params.route value:"
  file="src/routes/props/display-params.svelte">
  <div>{JSON.stringify(route, null, 2)}</div>
</Code>



---
File: /demo/src/routes/paths-and-params/paths-and-params.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { getStatusByValue, RouterInstance, StatusCode } from "@mateothegreat/svelte5-router";
  import type { RouteConfig, RouteResult } from "@mateothegreat/svelte5-router/route.svelte";
  import Router from "@mateothegreat/svelte5-router/router.svelte";
  import { onDestroy } from "svelte";
  import CustomNotFound from "./custom-not-found.svelte";
  import DisplayParams from "./display-params.svelte";
  import QuerystringMatching from "./querystring-matching.svelte";

  let router: RouterInstance = $state();
  let { route } = $props();

  let randoms = $state({
    float: (Math.random() * 1000).toFixed(2),
    int: (Math.random() * 1000).toFixed(0),
    string: (Math.random() * 1000).toFixed(2).toString()
  });

  const interval = setInterval(() => {
    randoms.float = (Math.random() * 1000).toFixed(2);
    randoms.int = (Math.random() * 1000).toFixed(0);
    randoms.string = (Math.random() * 1000).toFixed(2).toString();
  }, 750);

  onDestroy(() => {
    clearInterval(interval);
  });

  const routes: RouteConfig[] = [
    /**
     * This route will be used if there is no matching routes we
     * define below:
     */
    {
      component: snippet
    },
    /**
     * For this route, use querystring to match against the current location.search value:
     *
     *   ✅ /paths-and-params/query-matcher?number=2&number-as-string=2
     *   ✅ /paths-and-params/query-matcher?number=2.1&number-as-string=2.345
     *   ❌ /paths-and-params/query-matcher?number=2&number-as-string=two
     */
    {
      name: "match-number-and-string",
      path: "query-matcher",
      component: QuerystringMatching,
      querystring: {
        /**
         * The "number" querystring parameter:
         *
         *   - ✅ must be present
         *   - ✅ must be a number or a string that can be converted to a number
         */
        float: /^([\d.]+)$/,
        /**
         * The "number-as-string" querystring parameter:
         *
         *   - ✅ must be present
         *   - ✅ must be a number or a string that can be converted to a number
         */
        string: "123"
      }
    },
    /**
     * For this route, use querystring to match against the current location.search value:
     *
     *   ✅ /paths-and-params/query-matcher?pagination=1,10
     *   ✅ /paths-and-params/query-matcher?pagination=1&company=123
     *   ✅ /paths-and-params/query-matcher?pagination=1&company=1234567
     *   ✅ /paths-and-params/query-matcher?pagination=2,20&company=123
     *   ✅ /paths-and-params/query-matcher?pagination=2,20&company=1234567
     *   ❌ /paths-and-params/query-matcher?pagination=1,&company=123
     *   ❌ /paths-and-params/query-matcher?pagination=&company=123
     *   ❌ /paths-and-params/query-matcher?pagination=2,3,4
     *   ❌ /paths-and-params/query-matcher?pagination=bad-value
     */
    {
      name: "match-pagination",
      path: "query-matcher",
      component: QuerystringMatching,
      querystring: {
        /**
         * The "pagination" querystring parameter:
         *
         *   - ✅ must be present
         *   - ✅ must be a number
         *   - ❔ and then be followed by an optional "cursor" parameter:
         *     - ✅ it must have a comma delimiter
         *     - ✅ it must be a string of alphanumeric characters only
         */
        pagination: /^(?<page>\d+)(?:,(?<cursor>\d+))?$/,
        /**
         * The "company" querystring parameter is optional, but if present:
         *
         *   - ✅ can be empty
         *   - ✅ must be a single number
         */
        company: /^(\d+)?$/
      },
      props: {
        metadata: {
          src: "paths-and-params.svelte"
        }
      }
    },
    /**
     * This route will match any path and pass the pattern groups
     * as an object to the component that is passed in $props().
     *
     * The component will access the params using $props() and the
     * property "child" will contain the value extracted from the path.
     */
    {
      path: "extensions/(?<extension>.*)/(?<page>[^/]+)(?:/(?<rest>.*))?",
      component: DisplayParams
    },
    {
      name: "fancy-regex-capture-group",
      path: "(foo|bar).*",
      component: DisplayParams,
      props: {
        randomId: Math.random().toString(36).substring(2, 15),
        someUserStuff: {
          username: "mateothegreat",
          userAgent: navigator.userAgent
        }
      }
    }
  ];
</script>

{#snippet snippet()}
  <Container
    title={"{#snippet snippet()}"}
    file="src/routes/paths-and-params/paths-and-params.svelte">
    <div class="flex flex-col items-center gap-6 p-10 text-center">
      <Badge>There was no path provided to the router, so the default route was used (declared as a snippet).</Badge>
      Click on a link above to see the different effects!
    </div>
  </Container>
{/snippet}

<RouteWrapper
  {router}
  name="/paths-and-params"
  {route}
  end={true}
  title={{
    file: "src/routes/paths-and-params/paths-and-params.svelte",
    content: "This demo shows how to pass values downstream to the component that is rendered."
  }}
  links={[
    {
      href: "/paths-and-params",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/paths-and-params/foo",
      label: "foo"
    },
    {
      href: "/paths-and-params/query-matcher?pagination=2,23&company=123",
      label: "query-matcher?pagination=2,23&company=123"
    },
    {
      href: `/paths-and-params/query-matcher?string=123&float=${randoms.float}`,
      label: `query-matcher?string=123&float=${randoms.float}`
    }
  ]}>
  <Router
    id="props-router"
    basePath="/paths-and-params"
    bind:instance={router}
    {routes}
    hooks={{
      /**
       * You could use a global auth guard here to run before every route:
       *
       * hooks={{
       *   pre: (route: Routed) => {
       *     if (!isAuthenticated()) {
       *       console.warn("user is not authenticated, redirecting to login", route);
       *       return {
       *         component: NotGonnaMakeIt,
       *       };
       *     }
       *   }
       * }}
       *
       * You could also use a global error handler here to run after every route:
       *
       * hooks={{
       *   post: [
       *     (route: Routed) => {
       *       console.info("do some more work here", route);
       *       return true;
       *     },
       *     someLogMethod,
       *     finalMethod,
       *   ]
       * }}
       */
    }}
    statuses={{
      [StatusCode.NotFound]: (result: RouteResult) => {
        console.warn(`the path "${result.result.path.original}" could not be found :(`, {
          /**
           * You could use the status name to make something pretty:
           */
          status: getStatusByValue(StatusCode.NotFound),
          /**
           * You could also use the status code to something more dynamic:
           */
          code: StatusCode.NotFound
        });
        /**
         * Now, we're going to return a new route that will be rendered by the router:
         */
        return {
          component: CustomNotFound,
          /**
           * You can pass props to the component that is rendered if you need to
           * share some extra information:
           */
          props: {
            src: "props.svelte"
          }
        };
      }
    }} />
</RouteWrapper>



---
File: /demo/src/routes/paths-and-params/querystring-matching.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Code from "$lib/components/code.svelte";
  import InlineCode from "$lib/components/inline-code.svelte";

  let { route } = $props();
</script>

{#snippet content()}
  The route uses the pattern <InlineCode text="/\/?<child>.*)/" /> which captures everything after the base path and passes
  it to the component as the `params` prop.
{/snippet}

<div class="flex flex-col gap-4 border-t-2 border-slate-800 pt-4">
  <div class="flex flex-col gap-5">
    <div class="w-fit px-2 flex items-center gap-1 font-bold text-indigo-300 bg-gray-800 rounded-sm p-2">
      <InlineCode text="querystring" />
      match multiple values
      <InlineCode text="RegExp" />
      <InlineCode text="number" />
      <InlineCode text="string" />
      <InlineCode text="boolean" />
      <InlineCode text="array" />
    </div>
    <div class="flex flex-col gap-4 text-sm text-gray-400">
      <Badge
        variant="warning"
        class="w-fit">
        Matching will occur if <em><strong>all</strong></em>
        querystring keys and values match what was provided in the `querystring` configuration option.
      </Badge>
      <div class=" gap-1">
        This demo shows how to use the route's
        <InlineCode text="querystring" />
        configuration option to match against the current
        <InlineCode text="location.search" />
        value passed in by the browser.
      </div>
      <Badge
        variant="success"
        class="w-fit">
        There are 2 potential matches for the path "/paths-and-params/query-matcher". Notice how the active route is
        highlighted in green for this route only + the querystring matching.
      </Badge>
    </div>
  </div>
  <div class="flex flex-col gap-6 border-2 bg-gray-900/60 rounded-lg p-4 border-slate-700">
    <Code
      title="$props().route.result value:"
      file="src/routes/paths-and-params/querystring-matching.svelte">
      <div>{JSON.stringify(route.result, null, 2)}</div>
    </Code>
    <Code
      title="$props().route.route value:"
      file="src/routes/paths-and-params/querystring-matching.svelte">
      <div class="text-indigo-400">{JSON.stringify(route.route, null, 2)}</div>
    </Code>
  </div>
</div>



---
File: /demo/src/routes/patterns/dump.svelte
---

<script lang="ts">
  import { BadgeInfo } from "lucide-svelte";

  import { Lightbulb } from "lucide-svelte";

  import Code from "$lib/components/code.svelte";
  let { route, ...rest } = $props();
</script>

<div class="flex flex-col gap-3">
  <Code
    title="usage:"
    file="src/routes/extras/dump.svelte"
    language="svelte"
    class="flex-1">
    {`<script lang="ts">
  let { route, ...rest } = $props();
  console.log(route, rest);
</script>`}
  </Code>

  <div class="flex gap-3">
    <Code
      title="$props().route"
      language="json"
      class="flex-1">
      <div>{JSON.stringify(route, null, 2)}</div>
    </Code>

    <Code
      title="$props().rest"
      language="json"
      class="flex-1">
      <div>{JSON.stringify(rest, null, 2)}</div>
    </Code>
  </div>
</div>



---
File: /demo/src/routes/patterns/output.svelte
---

<div class="flex flex-col gap-4 p-4">
  <div>
    <h1 class="text-xl font-semibold text-slate-200">Nested Paths</h1>
    <p class="text-slate-400">
      This example will match any path that starts with `/path/path/path` and can be nested further.
    </p>
  </div>
  <div class="bg-slate-800/50 rounded-lg p-3">
    <h3 class="text-sm font-medium text-slate-300 mb-2">Route Props:</h3>
    <pre class="text-xs text-slate-400 overflow-auto">{JSON.stringify(props, null, 2)}</pre>
  </div>
</div>



---
File: /demo/src/routes/patterns/parameter-extraction.svelte
---

<script lang="ts">
  import { route } from "@mateothegreat/svelte5-router";

  import Code from "$lib/components/code.svelte";
  let { route: r, ...rest } = $props();
</script>

<div class="flex flex-col gap-1">
  <h1 class="text-lg font-semibold text-slate-300 flex items-center gap-1">Parameter Extraction</h1>
  <div class="text-slate-500 text-sm">
    <p>
      Given the following route config, everything after the "/parameter-extraction" will be available as a named
      parameter. This means that the following paths will be matched:
    </p>
    <ul class="list-disc list-inside">
      <li>
        <a
          use:route
          href="/patterns/parameter-extraction/foo">
          parameter-extraction/foo
        </a>
      </li>
      <li>
        <a
          use:route
          href="/patterns/parameter-extraction/bar">
          parameter-extraction/bar
        </a>
      </li>
      <li>
        <a
          use:route
          href="/patterns/parameter-extraction/baz">
          parameter-extraction/baz
        </a>
      </li>
    </ul>
  </div>
</div>

<div class="flex gap-3">
  <Code
    title="RouteConfig:"
    language="typescript"
    class="flex-1">
    {`  const routes: RouteConfig[] = [
  {
    path: /^\/parameter-extraction\/(?<child>.*)$/,
    component: ParameterExtraction
  }
];`}
  </Code>
  <Code
    title="$props().route.result.path.params"
    language="json"
    class="flex-1">
    <div>{JSON.stringify(r.result.path.params, null, 2)}</div>
  </Code>
</div>



---
File: /demo/src/routes/patterns/patterns.svelte
---

<script lang="ts">
  import { route, type RouteConfig } from "@mateothegreat/svelte5-router";
  import Router from "@mateothegreat/svelte5-router/router.svelte";
  import type { TableColumn } from "@mateothegreat/svelte5-table";
  import { DropinTable } from "@mateothegreat/svelte5-table";
  import { CirclePlay, Lightbulb, MousePointerClick } from "lucide-svelte";
  import { writable, type Writable } from "svelte/store";
  import Dump from "./dump.svelte";
  import ParameterExtraction from "./parameter-extraction.svelte";

  type Component = {
    name: string;
    description: string;
    path: string;
  };

  const columns: TableColumn[] = [
    {
      field: "name",
      header: "Routing Pattern"
    },
    {
      field: "description",
      header: "Description"
    },
    {
      field: "actions",
      header: customHeader,
      class: "w-[300px]",
      renderer: action
    }
  ];

  const components: Writable<Component[]> = writable([
    {
      name: "Default Route",
      description: "If the path is empty, the route will be matched otherwise evaluation will continue.",
      path: "/default-route"
    },
    {
      name: "Single Path",
      description: "This example will match any path that starts with `/path`.",
      path: "/single-path"
    },
    {
      name: "Nested Paths",
      description: "This example will match any path that starts with `/path/path/path` and can be nested further.",
      path: "/nested-paths"
    },
    {
      name: "Parameter Extraction",
      description: "Combine arbitrary paths and extractable parameters.",
      path: "/parameter-extraction"
    },
    {
      name: "Named Parameters",
      description:
        "This example will match any path that starts with `/path/path/path/path` and can be nested further.",
      path: "/named-parameters"
    }
  ]);

  let selections = writable([]);
  const routes: RouteConfig[] = [
    {
      path: "default-route",
      component: Dump
    },
    {
      path: "single-path",
      component: Dump
    },
    {
      path: /^\/parameter-extraction\/(?<child>.*)$/,
      component: ParameterExtraction
    }
  ];
</script>

{#snippet customHeader()}
  <div class="flex items-center gap-1 pl-2">
    Navigate to Demo
    <CirclePlay class="h-4 w-4 text-green-500" />
  </div>
{/snippet}

{#snippet action(row: any)}
  <div class="flex flex-1 ml-2">
    <a
      use:route
      href={`/patterns${row.path}`}
      class="bg-gray-800/50 flex items-center gap-1 rounded-sm border-2 border-purple-700 px-2 py-1 text-sm text-slate-500 transition-all hover:border-green-300 hover:bg-slate-200/20 hover:text-white duration-400">
      <MousePointerClick class="h-4 w-4" />
      <span class="text-green-500 flex items-center gap-0.5">
        goto("
        <span class="text-sky-400">
          {row.path}
        </span>
        ")
      </span>
    </a>
  </div>
{/snippet}

<div class="flex flex-col gap-4">
  <div class="flex flex-col gap-1">
    <h1 class="text-lg font-semibold text-slate-300 flex items-center gap-1">
      <Lightbulb class="h-5 w-5 text-cyan-400" />
      Routing Patterns
    </h1>
    <p class="text-slate-500 text-sm">This page contains an assortment of routing patterns to help you get started.</p>
  </div>
  <div class="bg-slate-700/20 text-slate-600 py-2 border-2 border-slate-700 rounded-lg">
    <DropinTable
      {columns}
      data={$components}
      bind:selections />
  </div>
  <div class="flex flex-1 flex-col gap-2">
    <Router
      basePath="/patterns"
      myExtraRouterProp={{
        calledFrom: "patterns <Router />"
      }}
      {routes} />
  </div>
</div>

<style>
  :global(td) {
    padding: 8px !important;
  }
</style>



---
File: /demo/src/routes/protected/manage-account/auth-guard-fast.ts
---

import { goto, type RouteResult } from "@mateothegreat/svelte5-router";

import { session } from "$lib/session.svelte";

export const authGuardFast = async (route?: RouteResult): Promise<boolean> => {
  console.log(
    `🔍 route.hooks["pre"] has been triggered for %c${route?.route.absolute()}`,
    "color: #F9A710; font-weight: bold;"
  );

  // Crude example of checking if the user is logged in. A more
  // sophisticated example would use a real authentication system
  // and a server-side API.
  console.log("🚧 %cdoing some work here...", "color: #2196f3; font-weight: bold; font-style: italic;");

  if (!localStorage.getItem("token")) {
    console.log("%c❌ redirecting to denied", "color: #f44336; font-weight: bold; font-size: 1.1em;");
    goto(`${session.mode === "hash" ? "#" : ""}/protected/login`);
    return false;
  }

  // If the user is logged in, return true so that the router can
  // continue it's navigation to the requested route.
  console.log(
    `%c✅ allowed to continue to %c${route?.absolute()}`,
    "color: #53FF4D; font-weight: bold;",
    "color: #F9A710; font-weight: bold;"
  );
  console.log("%c✅ returning true", "background: #4caf50; color: white; padding: 2px 5px; border-radius: 3px;");

  return true;
};



---
File: /demo/src/routes/protected/manage-account/auth-guard-slow.ts
---

import { goto, type RouteResult } from "@mateothegreat/svelte5-router";

import { session } from "$lib/session.svelte";

export const authGuardSlow = async (route?: RouteResult): Promise<boolean> => {
  console.log(
    `🔍 route.hooks["pre"] has been triggered for %c${route?.route.absolute()}`,
    "color: #F9A710; font-weight: bold;"
  );

  // Crude example of checking if the user is logged in. A more
  // sophisticated example would use a real authentication system
  // and a server-side API.
  console.log("🚧 %cdoing some work here...", "color: #2196f3; font-weight: bold; font-style: italic;");

  await new Promise((resolve) => setTimeout(resolve, 2000));

  if (!localStorage.getItem("token")) {
    console.log("%c❌ redirecting to denied", "color: #f44336; font-weight: bold; font-size: 1.1em;");
    goto(`${session.mode === "hash" ? "#" : ""}/protected/login`);
    return false;
  }

  // If the user is logged in, return true so that the router can
  // continue it's navigation to the requested route.
  console.log(
    `%c✅ allowed to continue to %c${route?.absolute()}`,
    "color: #53FF4D; font-weight: bold;",
    "color: #F9A710; font-weight: bold;"
  );
  console.log("%c✅ returning true", "background: #4caf50; color: white; padding: 2px 5px; border-radius: 3px;");

  return true;
};



---
File: /demo/src/routes/protected/manage-account/balance.svelte
---

<script lang="ts">
  import { ArrowDownRight, ArrowUpRight, DollarSign } from "lucide-svelte";
  import { fade } from "svelte/transition";

  // Fake account data
  const accountBalance = (Math.random() * 100000).toFixed(2);
  const transactions = [
    { id: 1, type: "credit", amount: 2500.0, description: "Salary Deposit", date: "2024-03-15" },
    { id: 2, type: "debit", amount: 85.5, description: "Grocery Store", date: "2024-03-14" },
    { id: 3, type: "debit", amount: 125.0, description: "Electric Bill", date: "2024-03-13" },
    { id: 4, type: "credit", amount: 500.0, description: "Freelance Payment", date: "2024-03-12" },
    { id: 5, type: "debit", amount: 45.99, description: "Online Shopping", date: "2024-03-11" }
  ];
</script>

<div
  class="p-6"
  in:fade={{ duration: 300 }}>
  <div class="mb-8 rounded-xl bg-blue-600 p-8 text-white shadow-lg">
    <h2 class="mb-2 text-xl">Current Balance</h2>
    <div class="flex items-center gap-2">
      <DollarSign size={32} />
      <span class="text-4xl font-bold">{accountBalance}</span>
    </div>
  </div>

  <div class="rounded-xl bg-white p-6 shadow-lg">
    <h3 class="mb-4 text-xl font-semibold text-gray-800">Recent Transactions</h3>
    <div class="space-y-4">
      {#each transactions as transaction}
        <div
          class="flex items-center justify-between rounded-lg border border-gray-200 p-4 transition-colors hover:bg-gray-50">
          <div class="flex items-center gap-3">
            {#if transaction.type === "credit"}
              <div class="rounded-full bg-green-100 p-2">
                <ArrowUpRight class="h-5 w-5 text-green-600" />
              </div>
            {:else}
              <div class="rounded-full bg-red-100 p-2">
                <ArrowDownRight class="h-5 w-5 text-red-600" />
              </div>
            {/if}
            <div>
              <p class="font-medium text-gray-800">{transaction.description}</p>
              <p class="text-sm text-gray-500">{transaction.date}</p>
            </div>
          </div>
          <span class={transaction.type === "credit" ? "text-green-600" : "text-red-600"}>
            {transaction.type === "credit" ? "+" : "-"}${transaction.amount.toLocaleString("en-US", {
              minimumFractionDigits: 2
            })}
          </span>
        </div>
      {/each}
    </div>
  </div>
</div>



---
File: /demo/src/routes/protected/manage-account/home.svelte
---

<script lang="ts">
  import { route } from "@mateothegreat/svelte5-router";
  import { Activity, PiggyBank, Send, Wallet } from "lucide-svelte";
  import { fade } from "svelte/transition";

  // Fake user data
  const userData = {
    name: "Svelte Boss",
    lastLogin: new Date().toLocaleString(),
    quickStats: [
      { title: "Total Balance", amount: "$45,250.80", icon: Wallet },
      { title: "Monthly Savings", amount: "$2,450.00", icon: PiggyBank },
      { title: "Recent Activity", count: "12 transactions", icon: Activity }
    ]
  };
</script>

<div
  class="p-6"
  in:fade={{ duration: 300 }}>
  <div class="mb-6">
    <h1 class="text-2xl text-gray-400">
      Welcome back,
      <span class="text-indigo-400 font-bold">{userData.name}</span>
    </h1>
    <p class="text-gray-400">Last login: {userData.lastLogin}</p>
  </div>

  <div class="grid gap-6 md:grid-cols-3">
    {#each userData.quickStats as stat}
      <div class="rounded-xl bg-slate-700/30 p-6 shadow-lg transition-transform hover:scale-[1.02]">
        <div class="mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-blue-100">
          <svelte:component
            this={stat.icon}
            class="h-6 w-6 text-blue-600" />
        </div>
        <h3 class="text-lg text-gray-400">{stat.title}</h3>
        <p class="mt-1 text-xl font-bold text-green-400">{stat.amount || stat.count}</p>
      </div>
    {/each}
  </div>

  <div class="mt-8">
    <a
      use:route
      href="/protected/manage-account/balance"
      class="flex items-center justify-center gap-2 rounded-lg bg-blue-600 px-6 py-4 font-semibold text-white transition-colors hover:bg-blue-700">
      <Send class="h-5 w-5" />
      View Balance
    </a>
  </div>
</div>



---
File: /demo/src/routes/protected/manage-account/manage-account.svelte
---

<script lang="ts">
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { session } from "$lib/session.svelte";
  import { goto, Router, RouterInstance } from "@mateothegreat/svelte5-router";
  import { ArrowRight, Building2, Shield, Wallet } from "lucide-svelte";
  import { client } from "../account-state.svelte";
  import { authGuardSlow } from "./auth-guard-slow";
  import Balance from "./balance.svelte";
  import Home from "./home.svelte";

  let router: RouterInstance = $state();
  let { route } = $props();
</script>

{#snippet snippet()}
  <div class="rounded-md border-4 border-slate-400 bg-gradient-to-b from-blue-100 to-blue-300">
    <div class="mx-auto max-w-6xl px-4 py-12">
      <div class="mb-16 text-center">
        <h1 class="mb-6 text-4xl font-bold text-blue-500 md:text-6xl">Welcome to SPA Router Bank!</h1>
        <p class="mb-8 text-xl text-black">Your trusted partner in routing.</p>
        <button
          onclick={() => goto("/protected/login")}
          class="mx-auto flex items-center gap-2 rounded-lg bg-blue-600 px-8 py-3 font-semibold text-white transition-colors hover:bg-blue-700">
          Login <ArrowRight size={20} />
        </button>
      </div>
      <div class="mb-16 grid gap-8 md:grid-cols-3">
        <div class="rounded-xl bg-white p-6 shadow-md transition-shadow hover:shadow-lg">
          <Shield class="mb-4 h-12 w-12 text-blue-600" />
          <h3 class="mb-2 text-xl font-semibold text-gray-800">Secure Banking</h3>
          <p class="text-gray-600">State-of-the-art security measures to protect your financial data</p>
        </div>
        <div class="rounded-xl bg-white p-6 shadow-md transition-shadow hover:shadow-lg">
          <Building2 class="mb-4 h-12 w-12 text-blue-600" />
          <h3 class="mb-2 text-xl font-semibold text-gray-800">Business Solutions</h3>
          <p class="text-gray-600">Comprehensive banking solutions for businesses of all sizes</p>
        </div>
        <div class="rounded-xl bg-white p-6 shadow-md transition-shadow hover:shadow-lg">
          <Wallet class="mb-4 h-12 w-12 text-blue-600" />
          <h3 class="mb-2 text-xl font-semibold text-gray-800">Personal Banking</h3>
          <p class="text-gray-600">Tailored financial services for your personal needs</p>
        </div>
      </div>
    </div>
  </div>
{/snippet}

<RouteWrapper
  {router}
  name="/protected/manage-account"
  {route}
  end={true}
  title={{
    file: "src/routes/protected/manage-account/manage-account.svelte",
    content: "This router demonstrates how you can restrict access to routes based on the user's authentication state."
  }}
  links={[
    {
      href: "/protected/manage-account",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/protected/manage-account/balance",
      label: "/protected/manage-account/balance"
    },
    {
      href: "/protected/manage-account/logout",
      label: "/protected/manage-account/logout"
    }
  ]}>
  <Router
    id="manage-account-router"
    basePath="/protected/manage-account"
    bind:instance={router}
    routes={[
      /**
       * This route is optional, it's for demonstration purposes.
       * It's used to redirect to the balance page when the user
       * navigates to the manage-account route (the default path):
       */
      {
        component: Home
      },
      {
        path: "/balance",
        component: Balance,
        hooks: {
          pre: authGuardSlow
        }
      },
      {
        path: "/logout",
        hooks: {
          pre: () => {
            client.loggedIn = false;
            setTimeout(() => {
              goto(`${session.mode === "hash" ? "#" : ""}/protected/login`);
            }, 100);
          }
        }
      }
    ]}
    {...myDefaultRouterConfig} />
</RouteWrapper>



---
File: /demo/src/routes/protected/manage-account/worker-client.svelte.ts
---

let working = $state(false);

export const workerClient = {
  get working() {
    return working;
  },
  set working(value: boolean) {
    working = value;
  }
};



---
File: /demo/src/routes/protected/account-state.svelte.ts
---

let token = $state(localStorage.getItem("token"));

export const client = {
  get loggedIn() {
    return token !== null;
  },
  set loggedIn(value: boolean) {
    token = value ? "true" : null;
    console.log("token", token);
    if (value) {
      localStorage.setItem("token", "true");
    } else {
      localStorage.removeItem("token");
    }
  }
};



---
File: /demo/src/routes/protected/denied.svelte
---

<script lang="ts">
  import { route } from "@mateothegreat/svelte5-router";
  import { LockIcon, ShieldAlert } from "lucide-svelte";
</script>

<div class="flex items-center justify-center bg-gray-50 px-4 py-12 sm:px-6 lg:px-8">
  <div class="w-full max-w-md space-y-8 rounded-lg bg-white p-8 shadow-lg">
    <div class="text-center">
      <div class="mb-4 flex justify-center">
        <ShieldAlert class="h-16 w-16 text-red-600" />
      </div>
      <h1 class="mb-2 text-3xl font-bold text-gray-900">Access Denied</h1>
      <div class="mb-4 flex items-center justify-center gap-2 text-red-600">
        <LockIcon class="h-5 w-5" />
        <span class="font-semibold">Secure Area</span>
      </div>
      <p class="mb-4 text-gray-600">For your security, access to this banking area has been denied. This may be due to:</p>
      <ul class="mb-6 ml-4 list-disc text-left text-gray-600">
        <li>Insufficient permissions</li>
        <li>Invalid authentication</li>
        <li>Session timeout</li>
      </ul>
      <p class="text-sm text-gray-500">Please contact our support team or return to the homepage if you believe this is an error.</p>
      <div class="mt-6">
        <a
          use:route
          href="/protected"
          class="inline-flex items-center rounded-md border border-transparent bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
          Return to Homepage
        </a>
      </div>
    </div>
  </div>
</div>



---
File: /demo/src/routes/protected/login.svelte
---

<script lang="ts">
  import { goto } from "@mateothegreat/svelte5-router";
  import { Shield } from "lucide-svelte";
  import { fade } from "svelte/transition";
  import { client } from "./account-state.svelte";
</script>

<div
  class="p-6"
  in:fade={{ duration: 300 }}>
  <div class="mx-auto max-w-md rounded-xl bg-white p-8 shadow-lg">
    <div class="mb-6 text-center">
      <div class="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-blue-100">
        <Shield class="h-8 w-8 text-blue-600" />
      </div>
      <h2 class="text-2xl font-bold text-gray-800">Secure Login</h2>
      <p class="mt-2 text-gray-600">Please log in to access your account</p>
    </div>

    <button
      class="w-full rounded-lg bg-blue-600 px-4 py-3 font-semibold text-white transition-colors hover:bg-blue-700"
      on:click={() => {
        client.loggedIn = true;
        goto("/protected/manage-account");
      }}>
      Login to Your Account
    </button>
  </div>
</div>



---
File: /demo/src/routes/protected/main.svelte
---

<script lang="ts">
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { goto, registry, Router, RouterInstance } from "@mateothegreat/svelte5-router";
  import { ArrowRight, Building2, Loader2, Shield, Wallet } from "lucide-svelte";
  import Denied from "./denied.svelte";
  import Login from "./login.svelte";
  import { authGuardFast } from "./manage-account/auth-guard-fast";

  let router: RouterInstance = $state();
  let { route } = $props();

  /**
   * This is a helper state variable that can be used to determine if the
   * current route is the same as the route that is being rendered so
   * that we can show a badge to indicate this is the last router in the
   * nested routing hierarchy.
   */
  let end = $state(true);

  $effect(() => {
    end =
      router.current?.result.path.condition === "default-match" ||
      location.pathname === "/protected/login" ||
      location.pathname === "/protected/denied";
  });
</script>

{#snippet snippet()}
  <div class="rounded-md border-4 border-slate-400 bg-gradient-to-b from-blue-100 to-blue-300">
    <div class="mx-auto max-w-6xl px-4 py-12">
      <div class="mb-16 text-center">
        <h1 class="mb-6 text-4xl font-bold text-blue-500 md:text-6xl">Welcome to SPA Router Bank!</h1>
        <p class="mb-8 text-xl text-black">Your trusted partner in routing.</p>
        <button
          onclick={() => goto("/protected/login")}
          class="mx-auto flex items-center gap-2 rounded-lg bg-blue-600 px-8 py-3 font-semibold text-white transition-colors hover:bg-blue-700">
          Login <ArrowRight size={20} />
        </button>
      </div>
      <div class="mb-16 grid gap-8 md:grid-cols-3">
        <div class="rounded-xl bg-white p-6 shadow-md transition-shadow hover:shadow-lg">
          <Shield class="mb-4 h-12 w-12 text-blue-600" />
          <h3 class="mb-2 text-xl font-semibold text-gray-800">Secure Banking</h3>
          <p class="text-gray-600">State-of-the-art security measures to protect your financial data</p>
        </div>
        <div class="rounded-xl bg-white p-6 shadow-md transition-shadow hover:shadow-lg">
          <Building2 class="mb-4 h-12 w-12 text-blue-600" />
          <h3 class="mb-2 text-xl font-semibold text-gray-800">Business Solutions</h3>
          <p class="text-gray-600">Comprehensive banking solutions for businesses of all sizes</p>
        </div>
        <div class="rounded-xl bg-white p-6 shadow-md transition-shadow hover:shadow-lg">
          <Wallet class="mb-4 h-12 w-12 text-blue-600" />
          <h3 class="mb-2 text-xl font-semibold text-gray-800">Personal Banking</h3>
          <p class="text-gray-600">Tailored financial services for your personal needs</p>
        </div>
      </div>
    </div>
  </div>
{/snippet}

<RouteWrapper
  {router}
  name="/protected"
  {route}
  {end}
  title={{
    file: "src/routes/protected/main.svelte",
    content: "Demo to show how you can use hooks to control the navigation of your app to control authentication, etc."
  }}
  links={[
    {
      href: "/protected",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/protected/login",
      label: "/protected/login"
    },
    {
      href: "/protected/manage-account",
      label: "/protected/manage-account"
    },
    {
      href: "/protected/denied",
      label: "/protected/denied"
    }
  ]}>
  <Router
    id="protected-router"
    basePath="/protected"
    bind:instance={router}
    routes={[
      {
        component: snippet
      },
      {
        path: "login",
        component: Login
      },
      {
        path: "manage-account",
        component: async () => import("./manage-account/manage-account.svelte"),
        hooks: {
          pre: authGuardFast
        },
      },
      {
        path: "denied",
        component: Denied
      }
    ]}
    {...myDefaultRouterConfig} />
</RouteWrapper>

{#if registry.get("manage-account-router")?.navigating}
  <div class="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
    <div class="flex flex-col items-center gap-4 rounded-md border-2 border-green-400 bg-black/70 px-20 py-6">
      <Loader2 class="h-12 w-12 text-green-500  animate-spin" />
      <div class="text-slate-300 font-bold">Doing some work...</div>
      <div class="text-slate-400 w-96 text-center">
        We've added some pre and post hooks to the manage-account router to simulate doing some work.
      </div>
    </div>
  </div>
{/if}



---
File: /demo/src/routes/transitions/fade.svelte
---

<script>
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import InlineCode from "$lib/components/inline-code.svelte";
  import { fade } from "svelte/transition";
</script>

<div in:fade={{ duration: 500 }}>
  <Container
    title="Fade"
    file="src/routes/transitions/fade.svelte">
    <div class="flex flex-col items-center gap-6 bg-sky-600 p-10 text-center">
      <Badge variant="info">This is a transition that is applied to the component directly</Badge>
      <div class="flex flex-col gap-3">
        This is a transition that is applied to the component directly:
        <InlineCode text={"<div in:fade={{ duration: 300 }}>..</div>"} />
      </div>
    </div>
  </Container>
</div>



---
File: /demo/src/routes/transitions/slide.svelte
---

<script>
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import InlineCode from "$lib/components/inline-code.svelte";
  import { slide } from "svelte/transition";
</script>

<div in:slide={{ duration: 500 }}>
  <Container
    title="Slide"
    file="src/routes/transitions/slide.svelte">
    <div class="flex flex-col items-center gap-6 bg-indigo-600 p-10 text-center">
      <Badge variant="info">This is a transition that is applied to the component directly</Badge>
      <div class="flex flex-col gap-3">
        This is a transition that is applied to the component directly:
        <InlineCode text={"<div in:fade={{ duration: 300 }}>..</div>"} />
      </div>
    </div>
  </Container>
</div>



---
File: /demo/src/routes/transitions/transitions.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Container from "$lib/components/container.svelte";
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { Router, RouterInstance, type Route } from "@mateothegreat/svelte5-router";
  import Fade from "./fade.svelte";
  import Slide from "./slide.svelte";

  let { route } = $props();
  let router: RouterInstance = $state();

  const routes: Route[] = [
    {
      component: snippet
    },
    {
      path: "fade",
      component: Fade,
      props: {
        file: "src/routes/transitions/fade.svelte"
      }
    },
    {
      path: "slide",
      component: Slide,
      props: {
        file: "src/routes/transitions/slide.svelte"
      }
    }
  ];
</script>

{#snippet snippet()}
  <Container
    title={"{#snippet snippet()}"}
    file="src/routes/transitions/transitions.svelte">
    <div class="flex flex-col items-center gap-6 p-10 text-center">
      <Badge>There was no path provided to the router, so the default route was used (declared as a snippet).</Badge>
      Click on a link above to see the different effects!
    </div>
  </Container>
{/snippet}

<RouteWrapper
  {router}
  name="/transitions"
  {route}
  end={true}
  title={{
    content:
      "Demo to show how to use transitions with the router (spoiler: they're applied at the content level rather than within the router itself)."
  }}
  links={[
    {
      href: "/transitions",
      label: "default path",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/transitions/fade",
      label: "/transitions/fade"
    },
    {
      href: "/transitions/slide",
      label: "/transitions/slide"
    }
  ]}>
  <Router
    id="transitions-router"
    basePath="/transitions"
    bind:instance={router}
    {routes}
    {...myDefaultRouterConfig} />
</RouteWrapper>



---
File: /demo/src/routes/delayed.svelte
---

<div class="bg-indigo-400 p-10">
  <h1>
    a delayed route component, the text for "Navigating" will be "Navigating: busy" while this component is loading
  </h1>
</div>



---
File: /demo/src/routes/home.svelte
---

<script lang="ts">
  import Badge from "$lib/components/badge.svelte";
  import Code from "$lib/components/code.svelte";
  import InlineCode from "$lib/components/inline-code.svelte";
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { RouterInstance, type Route, type RouteResult } from "@mateothegreat/svelte5-router";
  import Router from "@mateothegreat/svelte5-router/router.svelte";
  import { Github, MessageCircleQuestion, Newspaper } from "lucide-svelte";

  let { route }: { route: RouteResult } = $props();
  let router: RouterInstance = $state();

  const routes: Route[] = [
    {
      // Starting paths with "/" is not required, but it's a good idea to
      // do so for clarity in some cases.
      //
      // The router will match this route if the path is "/welcome" or "/home/welcome"
      // because the base path is passed in as "/home" below.
      path: "/",
      component: welcome
    },
    {
      // Starting paths with "/" is not required, but it's a good idea to
      // do so for clarity in some cases.
      //
      // The router will match this route if the path is "/with-query-params" or "/home/with-query-params"
      // because the base path is passed in as "/home" below.
      path: "with-query-params",
      component: displayRouteProps
    }
  ];
</script>

{#snippet welcome()}
  <div class="flex flex-col gap-5 rounded-md border-2 border-gray-800 bg-gray-800/50 p-4 text-sm text-slate-300">
    <h1 class="text-xl font-bold">Single Page Application Router (SPAR) for Svelte 5+</h1>
    <p>
      <InlineCode
        text="@mateothegreat/svelte5-router"
        class="bg-black text-blue-500" /> is an SPA router for Svelte that allows you to divide & conquer your app with nested
      routers, snippets, and more.
    </p>
    <div class="flex gap-3">
      <div
        class="flex h-9 cursor-pointer items-center gap-1 rounded-sm border-2 border-slate-400 bg-violet-600 p-2 transition-all duration-500 hover:bg-blue-600">
        <Newspaper class="h-5 w-5" />
        <a
          target="_blank"
          href="https://github.com/mateothegreat/svelte5-router/blob/main/docs/readme.md"
          class="">
          Documentation
        </a>
      </div>
      <div
        class="flex h-9 cursor-pointer items-center gap-1 rounded-sm border-2 border-slate-400 bg-slate-600 p-2 transition-all duration-500 hover:bg-blue-600">
        <Github class="h-5 w-5" />
        <a
          target="_blank"
          href="https://github.com/mateothegreat/svelte5-router"
          class="">
          GitHub Repository
        </a>
      </div>
      <div
        class="flex h-9 cursor-pointer items-center gap-1 rounded-sm border-2 border-slate-400 bg-slate-600 p-2 transition-all duration-500 hover:bg-blue-600">
        <MessageCircleQuestion class="h-5 w-5" />
        <a href="https://github.com/mateothegreat/svelte5-router/issues">GitHub Issues</a>
      </div>
    </div>
    <div class="flex flex-col gap-2">
      <h2 class="text-lg font-semibold text-indigo-400">Features</h2>
      <ul class="list-disc space-y-1 pl-6 text-slate-300">
        <li>Built for Svelte 5 🚀!</li>
        <li>Divide & conquer - use nested routers all over the place</li>
        <li class="text-teal-400">Use components, snippets, or both 🔥!</li>
        <li>Use regex paths (e.g. /foo/(.*?)/bar) and/or named parameters together</li>
        <li>Use async routes simply with component: async () => import("./my-component.svelte")</li>
        <li class="font-bold">Add hooks to your routes to control the navigation flow 🔧</li>
        <li>Automagic styling of your anchor tags 💄</li>
        <li>Helper methods 🛠️ to make your life easier</li>
        <li>Debugging tools included 🔍</li>
      </ul>
    </div>
    <div class="flex items-center">
      Get started now with
      <InlineCode
        text="npm install @mateothegreat/svelte5-router"
        class="mx-1 bg-black" />
      and check out the
      <a
        class="mx-1 cursor-pointer text-violet-400 hover:text-green-500 hover:underline"
        href="https://github.com/mateothegreat/svelte5-router/blob/main/docs/getting-started.md">
        getting started guide..
      </a>
    </div>
  </div>
{/snippet}

{#snippet displayRouteProps()}
  <div class="flex flex-col gap-4 border-t-2 border-slate-800 pt-4">
    <div class="flex flex-col gap-5">
      <div class="w-fit px-2 flex items-center gap-1 font-bold text-indigo-300 bg-gray-800 rounded-sm p-2">
        match path
        <InlineCode text={route.route.path.toString()} />
        to
        <InlineCode text={`${route.route.path}?someQueryParam=123`} />
      </div>
      <div class="flex flex-col gap-4 text-sm text-gray-400">
        <div class=" gap-1">
          This demo shows how to use the route's
          <InlineCode text="querystring" />
          configuration option to match against the current
          <InlineCode text="location.search" />
          value passed in by the browser.
        </div>
        <Badge
          variant="success"
          class="w-fit">
          Because we did not specify any <InlineCode text="querystring" /> parameters, the route render regardless of the
          <InlineCode text="querystring" /> and will be passed to the component as shown below.
        </Badge>
      </div>
    </div>
    <Code
      title={"{#snippet displayRouteProps()}"}
      file="src/routes/home.svelte">
      {JSON.stringify(route.result, null, 2)}
    </Code>
  </div>
{/snippet}

<RouteWrapper
  {router}
  name="home-router"
  {route}
  end={true}
  title={{
    file: "src/routes/home.svelte",
    content:
      "This route is a child of the main app router where you are redirected to /home/welcome when landing on /home using a `pre` hook."
  }}
  links={[
    {
      href: "/home",
      label: "/home",
      options: {
        active: {
          absolute: true
        }
      }
    },
    {
      href: "/home/with-query-params?someQueryParam=123",
      label: "/home/with-query-params?someQueryParam=123"
    }
  ]}>
  <Router
    id="home-router"
    basePath="/home"
    bind:instance={router}
    {...myDefaultRouterConfig}
    {routes} />
</RouteWrapper>



---
File: /demo/src/routes/not-found.svelte
---

<script lang="ts">
  let { route } = $props();
  $inspect(route);
</script>

<div class="flex flex-col items-center justify-center gap-4">
  <pre class="rounded-md bg-gray-800 p-2 text-sm text-emerald-500">included from "not-found.svelte":</pre>
  <h1 class="text-2xl font-bold">404 not found :(</h1>
  <p class="text-sm text-gray-500">The page you are looking for does not exist.</p>
  <pre class="rounded-md bg-gray-900 p-2 text-sm text-gray-400">$props():

{JSON.stringify(route, null, 2)}
</pre>
</div>



---
File: /demo/src/app.css
---

@import "tailwindcss";
@config '../tailwind.config.ts';

/*
  The default border color has changed to `currentColor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentColor);
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 210 40% 98%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 0 0% 0%;
    --foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --ring: 212.7 26.8% 83.9%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}



---
File: /demo/src/app.svelte
---

<script lang="ts">
  import RouteWrapper from "$lib/components/routes/route-wrapper.svelte";
  import { myDefaultRouterConfig } from "$lib/default-route-config";
  import { session } from "$lib/session.svelte";
  import Extras from "$routes/extras/extras.svelte";
  import Home from "$routes/home.svelte";
  import Nested from "$routes/nested/nested.svelte";
  import PathsAndParams from "$routes/paths-and-params/paths-and-params.svelte";
  import Patterns from "$routes/patterns/patterns.svelte";
  import Protected from "$routes/protected/main.svelte";
  import Transitions from "$routes/transitions/transitions.svelte";
  import type { RouteConfig, RouteResult } from "@mateothegreat/svelte5-router";
  import { goto, logging, registry, type Route, Router, type RouterInstance } from "@mateothegreat/svelte5-router";
  import { BookHeart, Github, HelpCircle, MousePointerClick } from "lucide-svelte";

  /**
   * Only needed for the demo environment development.
   *
   * It is not needed for including the router package in your project.
   */
  if (import.meta.hot) {
    import.meta.hot.accept(() => {
      import.meta.hot!.invalidate();
    });
  }

  /**
   * This is a state variable that will hold the router instance.
   *
   * It can be used to access the current route, navigate, etc:
   */
  let router: RouterInstance = $state();

  /**
   * Get notified when the current route changes:
   */
  const route = $derived(router.current);
  $effect(() => {
    if (router.current) {
      logging.info(
        `🚀 I'm an $effect in app.svelte and i'm running because the current route is now ${router.current.result.path.original}!`
      );
    }
  });

  /**
   * Let's declare our routes for the main app router:
   */
  const routes: RouteConfig[] = [
    {
      // You can name your routes anything you want for tracking or debugging:
      name: "default-route",
      hooks: {
        pre: async (route: RouteResult) => {
          console.error(`redirecting to ${session.mode === "hash" ? "/#" : ""}/home using a pre hook!`, route);
          goto(`${session.mode === "hash" ? "/#" : ""}/home`);
        },
        post: async (route: RouteResult) => {
          console.error(`post hook fired for route`, route);
        }
      }
    },
    {
      path: "/patterns",
      component: Patterns
    },
    {
      // Here we use a regex to match the home route.
      // This is useful if you want to match a route that has a dynamic path.
      // The "?:" is used to group the regex without capturing the match:
      // path: /^\/($|home)$/,
      path: "home",
      component: Home,
      // Use hooks to perform actions before and after the route is resolved:
      hooks: {
        pre: async (route: Route): Promise<boolean> => {
          // console.log("pre hook #1 fired for route");
          return true; // Return true to continue down the route evaluation path.
        },
        // Hooks can also be an array of functions (async too):
        post: [
          // This is a post hook that will be executed after the route is resolved:
          (route: Route): boolean => {
            // console.log("post hook #1 fired for route");
            return true; // Return true to continue down the route evaluation path.
          },
          // This is an async post hook that will be executed after the route is resolved:
          async (route: Route): Promise<boolean> => {
            // console.log("post hook #2 (async) fired for route");
            return true; // Return true to continue down the route evaluation path.
          }
        ]
      }
    },
    {
      path: "nested",
      component: Nested
    },
    {
      path: "paths-and-params",
      component: PathsAndParams
    },
    {
      path: "protected",
      component: Protected
    },
    {
      path: "transitions",
      component: Transitions
    },
    {
      path: "extras",
      component: Extras
    }
  ];

  // This is a global pre hook that can be applied to all routes.
  // Here you could check if the user is logged in or perform some other
  // authentication checks:
  const globalAuthGuardHook = async (route: Route): Promise<boolean> => {
    console.warn("globalAuthGuardHook", route);
    // Return true so that the route can continue down its evaluation path.
    return true;
  };
</script>

<div class="flex h-screen flex-col gap-4 bg-zinc-700/25 p-4">
  <div class="flex items-start">
    <div class="flex flex-col gap-4">
      <a
        href="https://github.com/mateothegreat/svelte5-router"
        class="text-slate-400 hover:text-green-500"
        target="_blank">
        <Github class="h-6 w-6" />
      </a>
      <a
        href="https://github.com/mateothegreat/svelte5-router"
        class="text-slate-400 hover:text-green-500"
        target="_blank">
        <BookHeart class="h-6 w-6 text-fuchsia-500" />
      </a>
    </div>
    <div class="logo h-51 w-60">
      <img
        src="https://github.com/mateothegreat/svelte5-router/raw/dev/docs/assets/logo.png"
        alt="logo" />
    </div>
    <div class="m-4 flex-1 flex justify-end text-indigo-400 gap-2 text-xs">
      <div class="text-slate-500 text-sm mb-3.5 rounded-md border-2 bg-black px-2 py-1.5">
        demo version: <a
          href="https://github.com/mateothegreat/svelte5-router/tree/{window.__SVELTE5_ROUTER_VERSION__}"
          class="text-emerald-500 hover:text-blue-400 cursor-pointer"
          target="_blank">
          {window.__SVELTE5_ROUTER_VERSION__}
        </a>
      </div>
    </div>
  </div>
  <div class="flex-1 gap-4 flex flex-col">
    <div
      class="text-slate-500 justify-end items-center text-sm flex gap-2 rounded-md border-2 border-slate-700/75 bg-black/30 px-2 py-1.5">
      <MousePointerClick class="h-4 w-4 text-slate-500" />
      change url mode:
      <button
        class="flex items-center gap-1 rounded-md border-2 border-purple-600 bg-slate-900/50 font-semibold px-3 py-0.5 cursor-pointer hover:bg-slate-800 hover:border-green-600"
        class:text-orange-400={session.mode === "hash"}
        class:text-green-400={session.mode === "path"}
        onclick={() => {
          session.mode = session.mode === "hash" ? "path" : "hash";
        }}>
        {session.mode === "hash" ? "path" : "hash"}
      </button>
    </div>
    <RouteWrapper
      name="main app router"
      title={{
        file: "src/app.svelte",
        content:
          "This is the main app component, it contains the top level router and then uses nested routers to divide and conquer your complex routing requirements! 🚀"
      }}
      {router}
      {route}
      links={[
        {
          href: "/",
          label: "/",
          options: {
            active: {
              absolute: true
            }
          }
        },
        {
          href: "/home",
          label: "/home"
        },
        {
          href: "/patterns",
          label: "/patterns"
        },
        {
          href: "/protected",
          label: "/protected"
        },
        {
          href: "/paths-and-params",
          label: "/paths-and-params"
        },
        {
          href: "/nested",
          label: "/nested"
        },
        {
          href: "/transitions",
          label: "/transitions"
        },
        {
          href: "/404",
          label: "/404"
        },
        {
          href: "/extras",
          label: "/extras"
        }
      ]}>
      <div class="flex-1">
        <Router
          id="my-main-router"
          bind:instance={router}
          {routes}
          {...myDefaultRouterConfig} />
      </div>
    </RouteWrapper>
  </div>
</div>
<div
  class="fixed bottom-0 right-10 overflow-hidden rounded-t-md border-2 border-b-0 bg-neutral-950 text-xs text-gray-400">
  <p class="flex items-center gap-1.5 bg-black/80 p-2.5 text-sm font-medium text-slate-400">
    <a
      href="https://github.com/mateothegreat/svelte5-router/blob/main/docs/registry.md"
      class="text-yellow-300/70 hover:text-pink-500"
      target="_blank">
      <HelpCircle class="h-5 w-5" />
    </a>
    router registry
  </p>
  <table class="divide-y divide-gray-900 overflow-hidden rounded-md border-2 text-xs text-gray-400">
    <thead>
      <tr class="text-center tracking-wider text-slate-500">
        <th class="px-3 py-2 font-medium">Router Name</th>
        <th class="px-3 py-2 font-medium">Routes</th>
        <th class="px-3 py-2 font-medium">State</th>
        <th class="px-3 py-2 font-medium">Current Path</th>
      </tr>
    </thead>
    <tbody class="divide-y divide-gray-800 font-mono">
      {#each registry.instances.entries() as [key, instance]}
        <tr>
          <td class="px-3 py-2 text-left text-indigo-400">
            {key}
          </td>
          <td class="px-3 py-2 text-pink-500">
            {instance.routes.size}
          </td>
          <td class="px-3 py-2">
            {#if instance.navigating}
              <span class="text-green-500">busy</span>
            {:else}
              <span class="text-gray-500">idle</span>
            {/if}
          </td>
          <td class="px-3 py-2 text-green-500">
            {instance.current?.path || "<default>"}
          </td>
        </tr>
      {/each}
    </tbody>
  </table>
</div>



---
File: /demo/src/main.ts
---

import { mount } from "svelte";

import './app.css';
import App from './app.svelte';

const app = mount(App, {
  target: document.getElementById('app')!,
})

export default app



---
File: /demo/src/vite-env.d.ts
---

/// <reference types="svelte" />
/// <reference types="vite/client" />

import type { CompilerConfig } from "@mateothegreat/svelte5-router";

interface ImportMetaEnv {
  SPA_ROUTER: CompilerConfig;
}



---
File: /demo/cypress.config.ts
---

import { defineConfig } from "cypress";

export default defineConfig({
  component: {
    devServer: {
      framework: "svelte",
      bundler: "vite",
      viteConfig: {
        server: {
          port: 8173,
        },
      },
    },
  },
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
});



---
File: /demo/index.html
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<link rel="icon" type="image/svg+xml" href="/vite.svg" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Vite + Svelte + TS</title>
	</head>
	<body class="dark">
		<div id="app"></div>
		<script type="module" src="/src/main.ts"></script>
	</body>
</html>



---
File: /demo/svelte.config.ts
---

import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";

export default {
  preprocess: vitePreprocess(),
  vitePlugin: {
    inspector: {
      toggleKeyCombo: "alt-x",
      showToggleButton: "always",
      toggleButtonPos: "top-right"
    }
  }
};



---
File: /demo/tailwind.config.ts
---


/** @type {import('tailwindcss').Config} */
const config = {
  darkMode: ["class"],
  content: ["./src/**/*.{html,js,svelte,ts}", "../../src/**/*.{html,js,svelte,ts}"],
  safelist: ["dark"],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px"
      }
    },
    extend: {
      colors: {
        border: "hsl(var(--border) / <alpha-value>)",
        input: "hsl(var(--input) / <alpha-value>)",
        ring: "hsl(var(--ring) / <alpha-value>)",
        background: "hsl(var(--background) / <alpha-value>)",
        foreground: "hsl(var(--foreground) / <alpha-value>)",
        primary: {
          DEFAULT: "hsl(var(--primary) / <alpha-value>)",
          foreground: "hsl(var(--primary-foreground) / <alpha-value>)"
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
          foreground: "hsl(var(--secondary-foreground) / <alpha-value>)"
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
          foreground: "hsl(var(--destructive-foreground) / <alpha-value>)"
        },
        muted: {
          DEFAULT: "hsl(var(--muted) / <alpha-value>)",
          foreground: "hsl(var(--muted-foreground) / <alpha-value>)"
        },
        accent: {
          DEFAULT: "hsl(var(--accent) / <alpha-value>)",
          foreground: "hsl(var(--accent-foreground) / <alpha-value>)"
        },
        popover: {
          DEFAULT: "hsl(var(--popover) / <alpha-value>)",
          foreground: "hsl(var(--popover-foreground) / <alpha-value>)"
        },
        card: {
          DEFAULT: "hsl(var(--card) / <alpha-value>)",
          foreground: "hsl(var(--card-foreground) / <alpha-value>)"
        }
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)"
      },
      fontFamily: {
        sans: ["Inter"]
      }
    }
  }
};
export default config;



---
File: /demo/vite.config.ts
---

import { svelte } from "@sveltejs/vite-plugin-svelte";
import { svelteInspector } from "@sveltejs/vite-plugin-svelte-inspector";

import tailwindcss from "@tailwindcss/vite";

import path from "path";

import { defineConfig } from "vite";

import { vitePluginVersionMark } from "vite-plugin-version-mark";

import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [
    tsconfigPaths(),
    svelte(),
    svelteInspector({
      toggleKeyCombo: "alt-x",
      showToggleButton: "always",
      toggleButtonPos: "bottom-left"
    }),
    tailwindcss(),
    vitePluginVersionMark({
      // name: 'test-app',
      // version: '0.0.1',
      // command: 'git describe --tags',
      name: "svelte5-router",
      ifGitSHA: true,
      ifShortSHA: true,
      ifMeta: true,
      ifLog: true,
      ifGlobal: true
    })
  ],
  build: {
    sourcemap: true
  },
  define: {
    /** @type {import('@mateothegreat/svelte5-router').runtime.Config} */
    /**
     * The (optional) router package configuration for the compiler.
     */
    "import.meta.env.SPA_ROUTER": {
      /**
       * If enabled, tracing will be enabled providing rich tracing capabilities.
       */
      tracing: {
        level: 3,
        enabled: true,
        console: true
      },
      /**
       * The logging configuration for the router.
       */
      logging: {
        /**
         * The logging level that is applied.
         */
        level: 4,
        /**
         * Whether to log the trace to the browser console (optional).
         */
        console: false,
        /**
         * This method is called when a new trace is created (optional).
         *
         * You could use this to send the trace to a remote server, or store it
         * in a local database.
         *
         * This example uses a promise in the event that you are needing to
         * use async functionality.
         */
        sink: async (trace: any) => {
          await new Promise((resolve) => {
            console.log(trace);
            resolve(void 0);
          });
        }
      }
    }
  },
  resolve: {
    /**
     * This is only needed for the demo environment.
     *
     * It is not needed for including the router package in your project.
     */
    alias: {
      $lib: path.resolve(__dirname, "./src/lib"),
      $routes: path.resolve(__dirname, "./src/routes"),
      "@mateothegreat/svelte5-router": path.resolve(__dirname, "../src/lib")
    }
  }
});



---
File: /docs/actions.md
---

# Actions

The Svelte router provides powerful actions that can be used to enhance your routing experience. These actions are designed to be used with anchor (`<a>`) elements to handle navigation and manage active states.

## Available Actions

| Action | Description |
|--------|-------------|
| [`route`](#route) | Manages both navigation and active states of links. |
| [`active`](#active) | Handles active state management for styling links. |  

## Examples

### Basic Navigation Link

```svelte
<a href="/home" use:route>Home</a>
```

### Active State with Multiple Classes

```svelte
<a 
  href="/profile" 
  use:route={{
    default: { class: ['text-gray-600', 'hover:text-gray-900'] },
    active: { class: ['text-blue-600', 'font-bold'] }
  }}
>
  Profile
</a>
```

### Exact Path Matching

```svelte
<a 
  href="/settings" 
  use:route={{
    active: {
      class: 'active-link',
      absolute: true // Only active when path exactly matches /settings
    }
  }}
>
  Settings
</a>
```

### Query String Sensitive Navigation

```svelte
<a 
  href="/search?type=users" 
  use:route={{
    active: {
      class: 'active-search',
      querystring: true // Only active when querystring matches exactly
    }
  }}
>
  User Search
</a>
```

### Notes

- The `route` action automatically prevents default link behavior and handles navigation through the History API.
- When using `active`, you'll need to handle navigation separately if needed.
- Classes are applied dynamically based on the current route state.
- The `absolute` option is useful for preventing parent routes from being marked as active when child routes are active.
- The `querystring` option allows for precise matching including query parameters.

---

## `route`

The `route` action is the primary action for handling routing in your application. It manages both navigation and active states of links.

```svelte
<a href="/dashboard" use:route>Dashboard</a>
```

The `route` action accepts an options object with the following configuration:

```typescript
{
  default?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  },
  active?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  },
  loading?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  },
  disabled?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  }
}
```

- `default`: Options applied when the route is inactive.
- `active`: Options applied when the route is active.
- `loading`: Options applied when the route is loading.
- `disabled`: Options applied when the route is disabled.

Each state accepts the following properties:

- `absolute`: When `true`, effects only apply on exact path matches.
- `querystring`: When `true`, effects only apply when querystring exactly matches.
- `class`: CSS class(es) to apply when the state is active.

Example with options:

```svelte
<a 
  href="/dashboard" 
  use:route={{
    default: { class: 'text-gray-600' },
    active: { 
      class: 'text-blue-600 font-bold',
      absolute: true 
    }
  }}
>
  Dashboard
</a>
```

## `active`

The `active` action is a simplified version of `route` that only handles active state management without handling navigation events. This is useful when you want to style links based on the current route but handle navigation differently.

```svelte
<a href="/dashboard" use:active>Dashboard</a>
```

The `active` action accepts a subset of the route options, focusing only on the active state configuration:

```typescript
{
  active?: {
    absolute?: boolean;
    querystring?: boolean;
    class?: string | string[];
  }
}
```

Example with options:

```svelte
<a 
  href="/dashboard" 
  use:active={{
    active: {
      class: ['text-blue-600', 'font-bold'],
      absolute: true,
      querystring: true
    }
  }}
>
  Dashboard
</a>
```



---
File: /docs/changelog.md
---

## [2.15.2] - 2025-05-26

### 🐛 Bug Fixes

- Support list of defaults for route; fixes #76

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.15.1] - 2025-05-25

### 🐛 Bug Fixes

- Route result serialization to string; closes #73

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.15.0] - 2025-05-24

### 🚀 Features

- Additional props support @ <Router/> -> [child], closes #70

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.14.1] - 2025-03-27

### 🐛 Bug Fixes

- Hooks return to false; closes #63

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- *(docs)* Better explain named params

<!-- generated by git-cliff -->
## [2.14.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.13.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.12.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.11.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.10.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.9.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.8.0] - 2025-03-06

### 🚀 Features

- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.7.0] - 2025-03-06

### 🚀 Features

- Hash support
- Hash support

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.6.1] - 2025-03-05

### ⚙️ Miscellaneous Tasks

- Vercel cicd
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.6.0] - 2025-03-05

### 🚀 Features

- *(demo)* Awesomify /protected demo with making it rainr

### 🐛 Bug Fixes

- *(demo)* Show random querystring usage
- *(demo)* Show random querystring usage

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Clean up docs
- Clean up docs
- Vercel cicd
- Vercel cicd
- Vercel cicd
- Vercel cicd
- Vercel cicd
- Vercel cicd

<!-- generated by git-cliff -->
## [2.5.0] - 2025-03-05

### 🚀 Features

- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr
- *(demo)* Awesomify /protected demo with making it rainr

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.4.0] - 2025-03-05

### 🚀 Features

- *(demo)* Awesomify /protected demo with making it rainr

### 🐛 Bug Fixes

- Cicd
- Cicd

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.34] - 2025-03-05

### 🐛 Bug Fixes

- Cicd
- Better regexp instance handling
- Cicd

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.33] - 2025-03-04

### 🐛 Bug Fixes

- Cicd

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.32] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.31] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.30] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.29] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.28] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.27] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.26] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.25] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.24] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.23] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.22] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.21] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.20] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.19] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.18] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.17] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.16] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.15] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.14] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.13] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.12] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.11] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.10] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.9] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.8] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.7] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.6] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.5] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.4] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.3] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.2] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.1] - 2025-03-04

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.3.0] - 2025-03-04

### 🚀 Features

- Query param matchers; fix: same route, diff params #54
- Query param matchers; fix: same route, diff params #54; tracing
- Query param matchers; fix: same route, diff params #54; tracing
- Query param matchers; fix: same route, diff params #54; tracing
- Query param matchers; fix: same route, diff params #54; tracing

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.7] - 2025-02-28

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.6] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature
- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.5] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.4] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.3] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.2] - 2025-02-28

### 🐛 Bug Fixes

- Statuses signature
- Statuses signature

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.1] - 2025-02-28

### 📚 Documentation

- Update statuses doc
- Update statuses doc

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.2.0] - 2025-02-28

### 🚀 Features

- Better status mapping; added callable status code handlers

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.1.1] - 2025-02-28

### 🐛 Bug Fixes

- Options handling for <a> tags proper

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.1.0] - 2025-02-28

### 🚀 Features

- /protected demo
- /protected demo
- /protected demo
- /protected demo

### 💼 Other

- Refactor

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.57] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.56] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.55] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.54] - 2025-02-28

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.53] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.52] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.51] - 2025-02-28

### 🐛 Bug Fixes

- Package.json exports causing errors

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.50] - 2025-02-27

### 📚 Documentation

- Add transitions demo

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.49] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.48] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.47] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.46] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.45] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.44] - 2025-02-27

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release
- Prep cicd for v2 release
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.43] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json

<!-- generated by git-cliff -->
## [2.0.42] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- Prep cicd for v2 release
- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.41] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release
- Prep cicd for v2 release

<!-- generated by git-cliff -->
## [2.0.40] - 2025-02-26

### ⚙️ Miscellaneous Tasks

- *(release)* Update changelog and bumping package.json
- Prep cicd for v2 release

<!-- generated by git-cliff -->



---
File: /docs/debugging.md
---

# Debugging

There are a few way to debug things.

## Debug Logger

In your `vite.config.ts` file, you can add the following:

```ts
export default defineConfig({
  plugins: [svelte()],
  build: {
    sourcemap: true // If you want to use a debugger, add this!
  },
  define: {
    // Tell the router to log when we're in debug mode.
    // Otherwise, this statement is removed by the compiler (known as tree-shaking)
    // and all subsequent log statements are removed at build time:
    'import.meta.env.SPA_ROUTER': {
      logLevel: "debug"
    },
  }
});
```

This allows us to log when we're in debug mode otherwise
statements like this are removed by the compiler (known astree-shaking):

```ts
if (import.meta.env.SPA_ROUTER && import.meta.env.SPA_ROUTER.logLevel === "debug") {
  log.debug(this.config.id, "unregistered router instance", {
    id: this.config.id,
    routes: this.routes.size
  });
}
```

Putting it all together:

```svelte
<script lang="ts">
  import { Router, type RouterInstance } from "@mateothegreat/svelte5-router";

  let instance: RouterInstance;

  if (import.meta.env.SPA_ROUTER && import.meta.env.SPA_ROUTER.logLevel === "debug") {
    log.debug(instance.id, "dumping routes", {
      config: instance.config,
      routes: instance.routes,
      current: instance.current,
      navigating: instance.navigating
    });
  }
</script>

<Router bind:instance {routes}>
```

Example output:

![debug](./assets/debugging-logger.png)



---
File: /docs/getting-started.md
---

# Getting Started

## Installation

```bash
npm install @mateothegreat/svelte5-router
```

## Usage

In your `app.svelte` file, you can use the `Router` component to render your routes:

```svelte
<script lang="ts">
  import { Router, type RouteConfig } from "@mateothegreat/svelte5-router";

  const routes: RouteConfig[] = [
    {
      component: Home
    }
    {
      path: "products",
      component: Products
    },
    {
      path: "settings",
      component: Settings
    }
  ];
</script>

<Router {routes} />
```

When you navigate to the root route, the `Home` component will be rendered.

When you navigate to the `/products` route, the `Products` component will be rendered.

When you navigate to the `/settings` route, the `Settings` component will be rendered.



---
File: /docs/helpers.md
---

# Helpers

There are a few helpers that are available to you when using the router.

## `goto(path: string, queryParams?: Record<string, string>)`

Navigates to the given path by calling `goto("/path")`.

Example:

```ts
goto("/foo", { bar: "baz" });
```

This will navigate to `/foo?bar=baz`.

## `query(key: string): string | null`

Returns the value of the query parameter for the given key or null if the key does not exist.

## The `QueryString` class

A helper class for working with the query string.

> Check it out at [src/lib/query.svelte.ts](../src/lib/query.svelte.ts).
> or import it with:
>
> ```ts
> import { QueryString } from "@mateothegreat/svelte5-router";
> ```
>
> and start using it now!

Basic usage:

```ts
import { QueryString } from "@mateothegreat/svelte5-router";

const query = new QueryString();

query.get("foo", "bar"); // "bar"
query.set("baz", "qux");
query.toString();        // "foo=bar&baz=qux"
```

Using it with navigation:

```ts
import { QueryString } from "@mateothegreat/svelte5-router";

const query = new QueryString();

// ...
query.set("foo", "baz");
query.set("baz", "qux");
// ...

query.goto("/test"); // Navigates to "/test?foo=baz&baz=qux"
```

You can also pass a query object to the `goto` method:

```ts
goto("/test", { foo: "baz" }); // Navigates to "/test?foo=baz"
```



---
File: /docs/hooks.md
---

# Routing Hooks

 | Order | Event  | Scope       | Description                                |
 | ----- | ------ | ----------- | ------------------------------------------ |
 | 1.    | `pre`  | `<Router/>` | Always runs *before* a route is attempted. |
 | 2.    | `pre`  | `Route`     | Runs *before* the route is rendered.       |
 | 3.    | `post` | `Route`     | Runs *after* the route is rendered.        |
 | 4.    | `post` | `<Router/>` | Always runs *after* a route is rendered.   |

```ts
import { goto, type RouteResult } from "@mateothegreat/svelte5-router";

export const authGuard = async (route: RouteResult): Promise<boolean> => {
  console.log("simulating some login/auth check...");
  // Crude example of checking if the user is logged in. A more
  // sophisticated example would use a real authentication system
  // and a server-side API.
  if (!localStorage.getItem("token")) {
    console.warn("redirecting to denied");
    goto("/protected/denied");
    return false;
  }
  return true;
}

const globalPostHook1 = (route: RouteResult): boolean => {
  console.warn("globalPostHook1", route);
  // Return true so that the route can continue down its evaluation path.
  return true;
};

const globalPostHook2 = async (route: RouteResult): Promise<boolean> => {
  console.warn("globalPostHook2", route);
  // Return true so that the route can continue down its evaluation path.
  return true;
};
```

You can pass an array or single method for the `pre` and `post` hooks and you can
also mix and match asynchronous and synchronous hooks.

```svelte
<Router
  {routes}
  hooks={{
    pre: authGuard,
    post: [
      globalPostHook1,
      globalPostHook2
    ]
  }}
/>
```



---
File: /docs/props.md
---

# Passing Props

You can pass props to a route by using the `props` property on any route.

These props will be passed to the component via `$props()`:

```ts
const routes: RouteConfig[] = [
  {
    path: /\/(?<child>.*)/,
    component: DisplayParams,
    props: {
      randomId: Math.random().toString(36).substring(2, 15),
      someUserStuff: {
        username: "mateothegreat",
        userAgent: navigator.userAgent
      }
    }
  }
];
```

Then, in your component, you can access the prop like this:

```svelte
<script lang="ts">
  let { route } = $props();
</script>

<pre>{JSON.stringify(route, null, 2)}</pre>
```

When you navigate to `/props/bar?someQueryParam=123`, the output will be:

```json
{
  "route": {
    "params": {
      "child": "bar"
    },
    "props": {
      "randomId": "y3pbfi1mgmg",
      "someUserStuff": {
        "username": "mateothegreat",
        "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"
      }
    },
    "query": {
      "someQueryParam": "123"
    },
    "name": "props-fancy-regex",
    "path": {
      "before": "/\\/(?<child>.*)/",
      "after": "/props/bar"
    }
  }
}
```



---
File: /docs/readme.md
---

# Svelte 5 SPA Router 🚀 🔥

![logo](https://raw.githubusercontent.com/mateothegreat/svelte5-router/refs/heads/dev/docs/assets/logo-1000px.png)

<img src="https://raw.githubusercontent.com/mateothegreat/svelte5-router/refs/heads/dev/docs/assets/coverage.svg?sanitize=true" />

An SPA router for Svelte that allows you to divide & conquer your app with nested routers, snippets, and more.

> [!NOTE]
> Live demo: <https://demo.router.svelte.spa>
>
> API documentation: <https://docs.router.svelte.spa>

## Features

- Built for Svelte 5 🚀!
- Divide & conquer - use nested routers all over the place.
- Use components, snippets, or both 🔥!
- Use regex paths (e.g. `/foo/(.*?)/bar`) and/or named parameters together.
- Use async routes simply with `component: async () => import("./my-component.svelte")`.
- Add hooks to your routes to control the navigation flow 🔧.
- Automagic styling of your anchor tags 💄.
- Helper methods 🛠️ to make your life easier.
- Debugging tools included 🔍.

## Installation

```bash
npm install @mateothegreat/svelte5-router
```

## Table of Contents

- [Getting Started](https://github.com/mateothegreat/svelte5-router/blob/main/docs/getting-started.md)
- [Routing](https://github.com/mateothegreat/svelte5-router/blob/main/docs/routing.md)
- [Hooks](https://github.com/mateothegreat/svelte5-router/blob/main/docs/hooks.md)
- [Actions](https://github.com/mateothegreat/svelte5-router/blob/main/docs/actions.md)
- [Helper Methods](https://github.com/mateothegreat/svelte5-router/blob/main/docs/helpers.md)
- [Default Status Mapping](https://github.com/mateothegreat/svelte5-router/blob/main/docs/statuses.md)
- [The Router Registry](https://github.com/mateothegreat/svelte5-router/blob/main/docs/registry.md)
- [Route Styling](https://github.com/mateothegreat/svelte5-router/blob/main/docs/styling.md)
- [Accessing Props](https://github.com/mateothegreat/svelte5-router/blob/main/docs/props.md)
- [Debugging](https://github.com/mateothegreat/svelte5-router/blob/main/docs/debugging.md)



---
File: /docs/registry.md
---

# Router Registry

The router [registry](../src/lib/registry.svelte.ts) is a global object that is used to store route
instances and their associated routing configuration.

This registry updates as you navigate through your application and as `<Router />` components
are mounted and unmounted dynamically.

![registry](./assets/registry.png)

## Usage

Though the registry is managed internally, though you can access it to debug your application.

When `<Router />` is mounted, it will register itself in the registry.

When `<Router />` is unmounted, it will unregister itself from the registry.

You can access the __global__ registry to debug your application by adding the following to your application:

```svelte
<script lang="ts">
  import { registry } from "@mateothegreat/svelte5-router";
</script>

<div>
  {#each registry.instances.entries() as [id, instance]}
    <div>
      <pre>id: {id}</pre>
      <pre>routes: {instance.routes.size}</pre>
      <pre>current: {instance.current?.path || "<default>"}</pre>
      <pre>navigating: {instance.navigating ? "yes" : "no"}</pre>
    </div>
  {/each}
</div>
```

Or, you can access the __local__ registry directly from your `<Router />` component:

```svelte
<script lang="ts">
  import type { RouterInstance } from "@mateothegreat/svelte5-router";
  import { Router } from "@mateothegreat/svelte5-router";

  let instance = $state<RouterInstance>();

  $inspect(instance); // Outputs the registry instance to the console.
</script>

<Router bind:instance {routes} />
```



---
File: /docs/routing-patterns.md
---

# Routing Patterns

As your application grows, you'll likely need to use more complex routing patterns. This guide will cover the most common patterns and how to use them.
<p>The <abbr title="Hyper Text Markup Language">HTML</abbr> specification
is maintained by the <abbr title="World Wide Web Consortium">W3C</abbr>.</p>

asdf [^1]

<h1 class="style-me">header</h1>
<p data-toggle="modal">paragraph</p>

[<button>Click me</button>](https://www.google.com)

[[docs/readme]]asdf

## Table of Contents

- [Routing Patterns](#routing-patterns)
  - [Table of Contents](#table-of-contents)
  - [Default Route](#default-route)
  - [Single Path](#single-path)
  - [Nested Paths](#nested-paths)
  - [Parameter Extraction](#parameter-extraction)
  - [Named Parameters](#named-parameters)

## Default Route

This example demonstrates how to make a route be the default route under the following conditions:

Order of operations:

1. If the path is empty, the route will be matched otherwise evaluation will continue.
2. If no other route matches, the default route will be matched and evaluation will continue.
3. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

> [!NOTE]
> You can omit the `path` property to make the route the default route which is the
> same as `path: "/"` and `path: ""`.

```ts
const routes: RouteConfig[] = [
  {
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/",
    component: ComponentToRender 
  }
];
```

## Single Path

This example will match any path that starts with `/path`.

Order of operations:

1. If the path matches exactly, the route will be matched otherwise evaluation will continue.
2. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path",
    component: ComponentToRender 
  }
];
```

## Nested Paths

This example will match any path that starts with `/path/path/path` and can be nested further.

> [!NOTE]
> This example has a demo available at <https://demo.router.svelte.spa/nested>!

Order of operations:

1. If the path matches exactly, the route will be matched otherwise evaluation will continue.
2. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/path",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/path/path",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/path/path/path",
    component: ComponentToRender 
  }
];
```

## Parameter Extraction

Combine arbitrary paths and extractable parameters.

> [!NOTE]
> This example has a demo available at <https://demo.router.svelte.spa/paths-and-params>!

Order of operations:

1. If there are arbitrary paths, the route **must** contain all of them.
2. If there are parameters, the path **must** match the expression.
3. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

Examples:

**Unnamed Parameters**:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(.*?)/path/(.*?)",
    component: ComponentToRender 
  }
];
```

**Named Parameters**:

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(?<myParam>.*)/path/(?<myParam2>.*)",
    component: ComponentToRender 
  }
];
```

## Named Parameters

This example will match any path that starts with `/path/path/path/path` and can be nested further.

Order of operations:

1. If the path matches exactly, the route will be matched otherwise evaluation will continue.
2. If [statuses](./statuses.md) is present at the `<Router />` component and `404` is set, this route will then be matched and evaluation will end.

```ts
const routes: RouteConfig[] = [
  {
    path: "(?<myParam>.*)",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(?<myParam>.*)",
    component: ComponentToRender 
  }
];
```

```ts
const routes: RouteConfig[] = [
  {
    path: "/path/(?<myParam>.*)/path/(?<myParam2>.*)",
    component: ComponentToRender 
  }
];
```

a
[^1]: This is a footnote
b



---
File: /docs/routing.md
---

# Routing Usage

We provide an array of `RouteConfig` objects to the `Router` component.

Each `RouteConfig` object describes a route and its associated component.

## Pattern Matching

You can simply use static paths like `/foo` or dynamic paths like `/foo/(.*?)` with regex.

Example patterns:

| Pattern                                        | Description                                             |
| ---------------------------------------------- | ------------------------------------------------------- |
| `/`                                            | The root path.                                          |
| `/foo`                                         | A static path.                                          |
| `/foo/(.*?)`                                   | A dynamic path.                                         |
| `/cool/(.*?)/(.*?)`                            | A dynamic path with two parameters.                     |
| `(?<param1>.*)`                                | A dynamic path with a named parameter.                  |
| `^/users/(?<id>[a-z0-9]{25})(?:/(?<tab>.*))?$` | A dynamic path with a named parameter and optional tab. |

> When using named parameters, you can access them using the `$props()` function.
>
> For example, if the route is `/users/123/settings`, then `$props()` will be `{ id: "123", tab: "settings" }`.

## Parameter Extraction

Parameters that are capable of being parsed from the path are passed to the component through the `route` prop:

```svelte
<script>
  let { route } = $props();
</script>
```

When using named parameters such as `(?<id>[a-z0-9]{25})`, the parameter value will be passed through the `route` prop as an object:

```ts
const routes: RouteConfig[] = [
  {
    path: "/users/(?<id>[a-z0-9]{25})",
    component: User
  }
];
```

and can be accessed like this:

```svelte
<script>
  const userId = route.result.path.params.id;
</script>
```

For the full shape of `RouteResult` see the [API Reference](https://github.com/mateothegreat/svelte5-router/blob/main/src/lib/route.svelte.ts#L24).

## Examples

### Basic

The following example demonstrates a basic route configuration with two routes:

```ts
const routes: RouteConfig[] = [
  {
    // Notice that we don't need to specify the path.
    // The router will use this route as the default route when "/" is visited.
    component: Home
  },
  {
    path: "/about",
    component: About
  }
];
```

Passing the routes to the `<Router />` component:

```svelte
<Router {routes} />
```

## Full Example

The following example demonstrates a more complex route configuration with multiple routes and hooks:

```ts
const routes: RouteConfig[] = [
  // Example of a route that redirects to the home route:
  {
    path: "",
    hooks: {
      pre: () => {
        goto("/home");
      }
    }
  },
  {
    // Here we use a regex to match the home route.
    // This is useful if you want to match a route that has a dynamic path.
    // The "?:" is used to group the regex without capturing the match:
    path: /(?:^$|home)/,
    component: Home,
    // Use hooks to perform actions before and after the route is resolved:
    hooks: {
      pre: async (route: RouteResult): Promise<boolean> => {
        console.log("pre hook #1 fired for route");
        return true; // Return true to continue down the route evaluation path.
      },
      // Hooks can also be an array of functions (async too):
      post: [
        // This is a post hook that will be executed after the route is resolved:
        (route: RouteResult): boolean => {
          console.log("post hook #1 fired for route");
          return true; // Return true to continue down the route evaluation path.
        },
        // This is an async post hook that will be executed after the route is resolved:
        async (route: RouteResult): Promise<boolean> => {
          console.log("post hook #2 (async) fired for route");
          return true; // Return true to continue down the route evaluation path.
        }
      ]
    }
  },
  {
    path: "nested",
    component: Nested
  },
  {
    path: "async",
    // Routes can also be async functions that return a promise.
    // This is useful if you want to load a component asynchronously aka "lazy loading":
    component: async () => import("./lib/async/async.svelte")
  },
  {
    path: "delayed",
    component: Delayed,
    hooks: {
      pre: async (route: RouteResult): Promise<boolean> => {
        // Simulate a network delay by returning a promise that resolves after a second:
        return new Promise((resolve) =>
          setTimeout(() => {
            resolve(true);
          }, 1000)
        );
      }
    }
  },
  {
    path: "props",
    component: Props
  },
  {
    path: "protected",
    component: Protected
  },
  {
    path: "query-redirect",
    component: QueryRedirect
  },
  {
    path: "context",
    component: Context
  }
];

// This is a global pre hook that can be applied to all routes.
// Here you could check if the user is logged in or perform some other
// authentication checks:
const globalAuthGuardHook = async (route: RouteResult): Promise<boolean> => {
  console.warn("globalAuthGuardHook", route);
  // Return true so that the route can continue down its evaluation path.
  return true;
};
```



---
File: /docs/statuses.md
---

# Route Statuses

Each router instance can have a set of statuses that are rendered when a route
returns a specific status code such as 404 for "Not Found".

When a route returns a status code, the router will render the component or execute the function
specified in the `statuses` prop for that status code.

## Status Codes

Using the `StatusesMapping` enum, the following status codes are to be supported:

> [!NOTE]
> Currently, the `404` status code is implemented. We will be adding the
> other status codes in the future.

| Code    | Description           | Status          |
| ------- | --------------------- | --------------- |
| 301     | Permanent Redirect    | Coming Soon     |
| 302     | Temporary Redirect    | Coming Soon     |
| 400     | Bad Request           | Coming Soon     |
| 401     | Unauthorized          | Coming Soon     |
| 403     | Forbidden             | Coming Soon     |
| __404__ | __Not Found__         | __Implemented__ |
| 500     | Internal Server Error | Coming Soon     |

## `BadRouted` Object

When passing a function to the `statuses` value, the [`RouteResult`](../src/lib/route.ts) object is passed to that function.

It contains the following properties:

- `path`: The path that was attempted to be accessed
- `status`: The status code that was returned

## Usage

### Basic Usage

In this example, we will use the `NotFound` component to render when the router
returns a 404 status code because the route `/bad` does not exist.

First, we will create the `NotFound` component:

```svelte
<script lang="ts">
  let props = $props();
</script>

<div class="flex flex-col items-center justify-center gap-4">
  <pre class="rounded-md bg-gray-800 p-2 text-sm text-emerald-500">included from "not-found.svelte":</pre>
  <h1 class="text-2xl font-bold">404 not found :(</h1>
  <p class="text-sm text-gray-500">The page you are looking for does not exist.</p>
  <pre class="rounded-md bg-gray-900 p-2 text-sm text-gray-400">
    $props():
    {JSON.stringify(props, null, 2)}
  </pre>
</div>
```

Next, we will create the `Router` component and pass the `NotFound` component
to the `statuses` prop:

```svelte
<script lang="ts">
  import { Router, Route, StatusCode } from "@mateothegreat/svelte5-router";
  import NotFound from "./lib/not-found.svelte";

  const routes: RouteConfig[] = [
    // add routes here
  ];
</script>

<Router
  {routes}
  statuses={{
    [StatusCode.NotFound]: NotFound
  }} />
```

When you navigate to `/bad`, the `NotFound` component will be rendered because
the route `/bad` does not exist.

### Custom Usage

You can also pass a function to the `statuses` prop to have more control over the rendered component. The function receives a `BadRouted` object containing information about the failed route and must return an object with the component to render and any additional props:

```svelte
<script lang="ts">
  import { Router, type RouteConfig, StatusCode, getStatusByValue } from "@mateothegreat/svelte5-router";
  import NotFound from "./lib/not-found.svelte";

  const routes: RouteConfig[] = [
    // add routes here
  ];
</script>

<Router
  id="my-main-router"
  bind:instance
  {routes}
  statuses={{
     [StatusCode.NotFound]: (route: RouteResult) => {
      console.warn(
        `Route "${route.result.path.original}" could not be found :(`,
        {
          statusName: getStatusByValue(route.result.status),
          statusValue: route.result.status
        },
        route
      );
      return {
        component: NotFound,
        props: {
          somethingExtra: new Date().toISOString()
        }
      };
    }
  }} />
```

In this example, when a 404 error occurs:

1. The function logs a warning with details about the failed route
2. Returns the `NotFound` component with an additional prop `somethingExtra` containing the current timestamp
3. The `NotFound` component will receive both its default props and the extra props specified in the function



---
File: /docs/styling.md
---

# Routing Styling

You can have the router apply a class to the active route by setting the `active.class` option
when configuring your routes.

As the routes change, the router will apply the class to the active route while removing it from the previous active route(s).

## Configuration

This property can be a string or an array of strings:

> [!NOTE]
> This is a convenience feature and is not required. You can apply the class to the active route manually in your component.
>
> See <https://docs.router.svelte.spa/classes/RouteOptions.html> for more information.

Using a string:

```ts
export const myDefaultRouteConfig = {
  active: {
    class: "bg-yellow-500"
  }
};
```

Using an array of strings:

```ts
export const myDefaultRouteConfig = {
  active: {
    class: [
      "bg-yellow-500",
      "underline"
    ]
  }
};
```

## Usage

With our common configuration declared we can use it in our routes:

Import the common configuration:

```ts
<script lang="ts">
  import { myDefaultRouteConfig } from "./lib/common-stuff";
</script>
```

### Using `use:route`

```svelte
<a
  use:route={myDefaultRouteConfig}
  href="/props"
  class="py-1 hover:bg-blue-800 rounded bg-blue-600 px-3">
  /props
</a>
```

### Using `use:active`

You can also be more prescriptive and pass in the active class as an object.

> [!NOTE]
> This is functionally equivalent to using `use:route` with the same configuration.
> It is just a convenience method for when you don't need to pass in any other options.

```svelte
<a
  use:route
  use:active={{ active: { class: "bg-pink-500" } }}
  href="/baz"
  class="py-1 hover:bg-blue-800 rounded bg-blue-600 px-3">
  Click Me
</a>
```

Here we used two actions:

- `use:route`
  - This is the default action and is used to apply the active class to the active route.
- `use:active`
  - This is a convenience action that is used to apply the active class to the active route.



---
File: /src/lib/actions/active.svelte.ts
---

import { urls } from "../helpers/urls";

import { applyActiveClass } from "./apply-classes";
import type { RouteOptions } from "./options";

/**
 * Add the `active` class to the node if the current route matches the node's href.
 *
 * > Similar to {@link route}.
 *
 * Add `use:active` to an anchor element to manage active state.
 *
 * @param {HTMLAnchorElement} node The anchor element to handle.
 *
 * @category Actions
 * @source
 */
export const active = (node: HTMLAnchorElement, options: Pick<RouteOptions, "active"> = {}) => {
  let url = urls.parse(node.href);

  const apply = () => {
    applyActiveClass(url, options, node);
  };

  apply();

  window.addEventListener("pushState", apply);

  return {
    destroy() {
      window.removeEventListener("pushState", apply);
    }
  };
};



---
File: /src/lib/actions/apply-classes.ts
---

import { urls, type URL } from "../helpers/urls";

import { RouteOptions } from "./options";

/**
 * Applies the active class to the node if the href is the same as the current location.
 *
 * @param href - The href to check if it is the same as the current location.
 * @param options - The options to apply to the node.
 * @param node - The node to apply the active class to.
 *
 * @category Actions
 */
export const applyActiveClass = (href: URL, options: RouteOptions, node: HTMLAnchorElement) => {
  const url = urls.parse(location.toString());
  if (
    (href.path === url.path ||
      href.path === url.hash.path ||
      href.hash.path === url.path ||
      (!options.active?.absolute && url.path.startsWith(href.path))) &&
    (options.active?.querystring || options.active?.querystring === undefined) &&
    (href.query.original == "" ||
      href.query.original === location.search.replace("?", "") ||
      href.query.original === url.hash.query.original)
  ) {
    if (Array.isArray(options.active?.class)) {
      node.classList.add(...options.active?.class);
    } else {
      node.classList.add(options.active?.class);
    }
    if (options.default?.class) {
      node.classList.remove(...options.default?.class);
    }
  } else {
    if (Array.isArray(options.active?.class)) {
      node.classList.remove(...options.active?.class);
      if (options.default?.class) {
        node.classList.add(...options.default?.class);
      }
    } else {
      if (options.active?.class) {
        node.classList.remove(options.active?.class);
      }
      if (options.default?.class) {
        node.classList.add(...options.default?.class);
      }
    }
  }
};



---
File: /src/lib/actions/index.ts
---

export * from "./apply-classes";
export * from "./options";
export * from "./route.svelte";



---
File: /src/lib/actions/options.ts
---

/**
 * Options that are applied to the html element when the route is active, inactive,
 * loading, or disabled.
 *
 * @category Router
 */
export type RouteOptionState = {
  /**
   * When true, the effects will only be applied if the path is an exact match.
   *
   * This is useful for when you want to apply the effects to a specific route, but
   * not when it's part of a parent route.
   */
  absolute?: boolean;

  /**
   * When true, the effects will only be applied if the querystring is an exact match.
   */
  querystring?: boolean;

  /**
   * The css class(es) to add when this state is currently active.
   */
  class?: string | string[];
};

/**
 * Options for the route action.
 *
 * @category Router
 */
export class RouteOptions {
  /**
   * When the route is inactive, these options are applied.
   */
  default?: RouteOptionState;

  /**
   * When the route is active, these options are applied.
   */
  active?: RouteOptionState;

  /**
   * The css class(es) to add when route is loading.
   */
  loading?: RouteOptionState;

  /**
   * When the route is disabled, these options are applied.
   */
  disabled?: RouteOptionState;

  constructor(options?: Partial<RouteOptions>) {
    if (options) {
      Object.assign(this, options);
    }
  }
}



---
File: /src/lib/actions/route.svelte.ts
---

import { urls } from "../helpers/urls";

import { applyActiveClass } from "./apply-classes";
import type { RouteOptions } from "./options";

/**
 * Svelte action to handle routing with optional active state.
 *
 * Similar to {@link active}
 *
 * Add `use:route` to an anchor element to handle routing and optionally manage active state.
 *
 * @param {HTMLAnchorElement} node The anchor element to handle.
 * @param {RouteOptions} options Options for the route action (optional).
 * @category Actions
 * @includeExample demo/src/app.svelte
 * @source
 */
export const route = (node: HTMLAnchorElement, options: RouteOptions = {}) => {
  let url = urls.parse(node.href);

  const apply = () => {
    applyActiveClass(url, options, node);
  };

  /**
   * Handle click events on the anchor element.
   * @param event - The click event.
   */
  const handleClick = (event: Event) => {
    event.preventDefault();
    window.history.pushState({}, "", node.href);
    applyActiveClass(url, options, node);
  };

  apply();

  node.addEventListener("click", handleClick);
  window.addEventListener("pushState", apply);
  return {
    destroy() {
      node.removeEventListener("click", handleClick);
      window.removeEventListener("pushState", apply);
    }
  };
};



---
File: /src/lib/helpers/evaluators.test.ts
---

import { describe, expect, test } from "vitest";

import { evaluators } from "./evaluators";
import { Identities } from "./identify";
import { regexp } from "./regexp";

describe("regexp", () => {
  test("should convert ^home$ to a RegExp", () => {
    expect(regexp.from("^home$")).toBeInstanceOf(RegExp);
  });

  test("should convert /^home$/ to a RegExp", () => {
    expect(regexp.from("/^home$/")).toBeInstanceOf(RegExp);
  });

  test("should convert a RegExp to a RegExp", () => {
    expect(regexp.from(/^home$/)).toBeInstanceOf(RegExp);
  });

  test("should convert ^/($|home)$ to a RegExp", () => {
    expect(regexp.from("^/($|home)$")).toBeInstanceOf(RegExp);
  });

  test("should convert /(^home$/ to a RegExp", () => {
    expect(() => regexp.from("/(^home$/")).toThrowError();
  });
});

describe("evaluators", () => {
  test("should return true for a non-empty object", () => {
    expect(evaluators.valid[Identities.object]({ a: 1 })).toBe(true);
  });

  test("should return false for an empty-ish object", () => {
    expect(evaluators.valid[Identities.object]({ a: undefined })).toBe(false);
  });

  test("should return false for an empty-ish nested object", () => {
    expect(evaluators.valid[Identities.object]({ a: undefined, b: true })).toBe(false);
  });

  test("should return false for an empty-ish nested nested object", () => {
    expect(evaluators.valid[Identities.object]({ a: 0, b: { c: null } })).toBe(false);
  });
});



---
File: /src/lib/helpers/evaluators.ts
---

import { identify, Identities } from "./identify";
import { marshal } from "./marshal";
import type { ReturnParam } from "./urls";

/**
 * Path or querystring evaluation result.
 *
 * @category Router
 */
export type Condition =
  | "exact-match"
  | "base-match"
  | "default-match"
  | "no-match"
  | "permitted-no-conditions"
  | "one-or-more-missing";

/**
 * The conditions that are considered successful.
 *
 * @category Router
 */
export const SuccessfulConditions: Condition[] = [
  "exact-match",
  "base-match",
  "default-match",
  "permitted-no-conditions"
];

/**
 * The conditions that are considered failed.
 *
 * @category Router
 */
export const FailedConditions: Condition[] = ["no-match", "one-or-more-missing"];

/**
 * The evaluation results of the route.
 *
 * @category Router
 */
export type Evaluation = {
  condition: Condition;
  params?: ReturnParam;
};

/**
 * The evaluation results of the route.
 *
 * @category Router
 */
export type EvaluationResult = {
  path: Evaluation;
  querystring: Evaluation;
  original: ReturnParam;
};

export namespace evaluators {
  /**
   * Composite evaluator function that can handle different types of values.
   *
   * @param a - The first value to evaluate.
   * @param b - The second value to evaluate {a} against.
   * @returns A boolean, string[], or object.
   */
  export const any: Record<
    string,
    (
      a: any,
      b: any
    ) =>
      | boolean
      | boolean[]
      | number
      | number[]
      | string
      | string[]
      | { [key: string]: boolean | boolean[] | number | number[] | string | string[] }
  > = {
    [Identities.string]: (a, b) => a === b,
    [Identities.number]: (a, b) => a === b,
    [Identities.boolean]: (a, b) => a === b,
    [Identities.promise]: (a, b) => a === b,
    [Identities.function]: (a, b) => a === b,
    [Identities.null]: (a, b) => a === b,
    [Identities.undefined]: (a, b) => a === b,
    [Identities.unknown]: (a, b) => a === b,
    [Identities.array]: (a, b) =>
      Array.isArray(a) &&
      Array.isArray(b) &&
      a.length === b.length &&
      a.every((value, index) => any[identify(value)](value, b[index])),
    [Identities.object]: (a, b) => {
      if (typeof a !== "object" || typeof b !== "object") {
        return false;
      }
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      return aKeys.every((key) => any[identify(a[key])](a[key], b[key]));
    },
    [Identities.regexp]: (a, b) => {
      const result = (a as RegExp).exec(b);
      if (result) {
        if (result.groups) {
          return marshal(result.groups).value as { [key: string]: string };
        } else {
          if (result.length === 1 && result[0] === result.input) {
            return true;
          }
          return marshal(result.slice(1)[0]).value as string[];
        }
      }
      return false;
    }
  };

  /**
   * Evaluator function that checks if a value is empty recursively.
   *
   * @category Router
   */
  export const valid: Record<string, (a: any) => boolean> = {
    [Identities.string]: (a) => a.length > 0,
    [Identities.boolean]: (a) => a === false,
    [Identities.number]: (a) => !isNaN(a),
    [Identities.array]: (a) => Array.isArray(a) && a.length > 0,
    [Identities.object]: (a) => {
      if (typeof a !== "object" || a === null) {
        return true;
      }
      const keys = Object.keys(a);
      if (keys.length === 0) {
        return true;
      }
      const result = keys.every((key) => {
        const value = a[key];
        const valueType = identify(value);
        return valid[valueType](value);
      });
      return result;
    },
    [Identities.regexp]: (a) => a instanceof RegExp,
    [Identities.function]: (a) => typeof a === "function",
    [Identities.null]: () => false,
    [Identities.undefined]: () => false
  };
}



---
File: /src/lib/helpers/goto.ts
---

/**
 * Navigate to a new path by using the browser's history API (pushState specifically).
 *
 * @param path - The path to navigate to (excluding the base URL).
 * @param queryParams - The query parameters to add to the URL.
 *
 * @category Helpers
 */
export const goto = (path: string, queryParams?: Record<string, unknown>): void => {
  const url = new URL(path, window.location.origin);
  if (queryParams) {
    Object.entries(queryParams).forEach(([key, value]) => {
      url.searchParams.set(key, value as string);
    });
  }
  window.history.pushState({}, "", url.toString());
};



---
File: /src/lib/helpers/identify.ts
---

export type Identity =
  | string
  | number
  | boolean
  | null
  | undefined
  | RegExp
  | Function
  | Object
  | Array<unknown>
  | Promise<unknown>;

export const Identities = {
  string: "string",
  number: "number",
  boolean: "boolean",
  null: "null",
  undefined: "undefined",
  regexp: "regexp",
  function: "function",
  object: "object",
  array: "array",
  promise: "promise",
  unknown: "unknown"
};

export const identify = (value: unknown): (typeof Identities)[keyof typeof Identities] => {
  if (value === null) {
    return Identities.null;
  }
  if (value === undefined) {
    return Identities.undefined;
  }
  if (value instanceof RegExp) {
    return Identities.regexp;
  }
  if (typeof value === "string") {
    return Identities.string;
  }
  if (typeof value === "number") {
    return Identities.number;
  }
  if (typeof value === "boolean") {
    return Identities.boolean;
  }
  if (Array.isArray(value)) {
    return Identities.array;
  }
  if (typeof value === "function") {
    return Identities.function;
  }
  if (typeof value === "object") {
    return Identities.object;
  }
  return Identities.unknown;
};



---
File: /src/lib/helpers/index.ts
---

export * from "./evaluators";
export * from "./goto";
export * from "./identify";
export * from "./logging";
export * from "./marshal";
export * from "./normalize";
export * from "./objects";
export * from "./query";
export * from "./regexp";
export * from "./runtime";
export * from "./tracing.svelte";
export * from "./urls";



---
File: /src/lib/helpers/logging.ts
---

import { runtime } from "./runtime";

/**
 * Logging facility.
 *
 * @category Helpers
 */
export namespace logging {
  /**
   * Acceptable log levels (applies to all logging methods).
   */
  export enum LogLevel {
    FATAL = -1,
    ERROR = 1,
    INFO = 2,
    DEBUG = 3,
    TRACE = 4,
    DISABLED = 5
  }

  /**
   * A grouping of log messages.
   */
  export type Group = {
    name: string;
    messages: any | any[];
  };

  /**
   * Acceptable log types typed out so that it's clearer what can be
   * passed to the logging functions like groups of logs to combine them
   * in the outputs.
   */
  export type Log = Group | Group[] | any | any[];

  /**
   * Convenience method for logging an info message.
   */
  export const info = (...msg: Log[]): void => {
    log(LogLevel.INFO, ...msg);
  };

  /**
   * Convenience method for logging a debug message.
   */
  export const debug = (...msg: Log[]): void => {
    log(LogLevel.DEBUG, ...msg);
  };

  /**
   * Convenience method for logging an error message.
   */
  export const error = (...msg: any[]): void => {
    log(LogLevel.ERROR, ...msg);
  };

  /**
   * Convenience method for logging a trace message.
   */
  export const trace = (...msg: any[]): void => {
    log(LogLevel.TRACE, ...msg);
  };

  /**
   * Convenience method for logging a fatal error and finally throwing an error.
   *
   * @remarks
   * This is used to stop the application from running if an error is encountered
   * that is not recoverable.
   */
  export const fatal = (...msg: any[]): void => {
    log(LogLevel.FATAL, ...msg);
    throw new Error("Fatal error");
  };

  /**
   * Raw log method.
   */
  export const log = (level: LogLevel, ...msg: Log[]): void => {
    if (level <= runtime.current.logging.level && level !== LogLevel.DISABLED) {
      if (runtime.current.logging.console) {
        if (msg.some((m) => m?.toConsole)) {
          msg.forEach((m) => m?.toConsole?.(runtime.current.logging.level));
        } else if (runtime.current.logging.console) {
          console.log(...msg);
        }
      }
      if (runtime.current.logging.sink) {
        runtime.current.logging.sink(msg);
      }
    }
  };
}



---
File: /src/lib/helpers/marshal.test.ts
---

import { describe, expect, test } from "vitest";

import { Identities } from "./identify";
import { marshal } from "./marshal";

describe("marshal", () => {
  test("should marshal an array from a string", () => {
    expect(marshal("a[0]=1")).toEqual({
      identity: Identities.object,
      value: {
        a: [1]
      }
    });
  });

  test("should marshal an array from a string with multiple values", () => {
    expect(marshal("a[0]=first&nonarray=true,a[999]=true&a[1]=second&a[2]=3&a[3]=fourth")).toEqual({
      identity: Identities.object,
      value: {
        nonarray: true,
        a: ["first", "second", 3, "fourth", true]
      }
    });
  });

  test("should marshal an array from a string with an empty value", () => {
    expect(marshal("a[0]=1&a[1]=b&a[2]=false&a[3]=true&a[4]=")).toEqual({
      identity: Identities.object,
      value: {
        a: [1, "b", false, true, ""]
      }
    });
  });
});



---
File: /src/lib/helpers/marshal.ts
---

import { Identities, type Identity } from "./identify";

export type MarshallableType = string | number | boolean | RegExp | Function | Promise<unknown>;

export type Marshalled<T> = {
  identity: Identity;
  value: T;
};

/**
 * Marshal a value to a specific type.
 *
 * @param value - The value to marshal
 *
 * @returns The marshaled value
 */
export const marshal = <T>(value: unknown): Marshalled<T> => {
  // Most values will be strings, so we check for that first:
  if (typeof value === "string") {
    // Check for floats:
    if (value.match(/^[\d.-]+$/)) {
      if (!Number.isNaN(Number.parseFloat(value))) {
        return {
          identity: Identities.number,
          value: Number.parseFloat(value) as T
        };
      }
      // If the value is capable of being parsed as a number, we do that:
      if (!Number.isNaN(Number.parseInt(value))) {
        return {
          identity: Identities.number,
          value: Number.parseInt(value) as T
        };
      } else {
        return {
          identity: Identities.string,
          value: value as T
        };
      }
    } else if (!value.includes(",") && (value.includes("&") || value.includes("="))) {
      // Handle both array notation (x[0]=1) and simple key-value pairs (a=1&b=2)
      const pairs = value.split(/[&,]/);
      const result: Record<string, unknown> = {};

      for (const pair of pairs) {
        if (!pair.includes("=")) continue;
        const [key, val] = pair.split("=");
        // Remove array notation if present, otherwise use the key as is
        const cleanKey = key.replace(/\[\d*\]$/, "");
        const marshalled = marshal(val);

        if (key.includes("[")) {
          // Handle array case
          if (!Array.isArray(result[cleanKey])) {
            result[cleanKey] = [];
          }
          const index = key.match(/\[(\d+)\]/)?.[1];
          if (index) {
            // Store index and value as tuple to sort later
            if (!Array.isArray(result[cleanKey])) {
              result[cleanKey] = [];
            }
            (result[cleanKey] as [number, unknown][]).push([parseInt(index), marshalled.value]);
          } else {
            (result[cleanKey] as unknown[]).push(marshalled.value);
          }
        } else {
          // Handle simple key-value case
          result[cleanKey] = marshalled.value;
        }
      }

      // Transform arrays while preserving non-array values
      for (const [key, value] of Object.entries(result)) {
        if (Array.isArray(value) && value.length > 0 && Array.isArray(value[0])) {
          // Sort by index and extract values only for array entries
          result[key] = (value as [number, unknown][]).sort((a, b) => a[0] - b[0]).map(([, val]) => val);
        }
      }

      return {
        identity: Identities.object,
        value: result as T
      };
    } else if (value.includes("&") && value.includes("=")) {
      const result: Record<string, unknown> = {};

      for (const pair of value.split("&")) {
        if (!pair.includes("=")) continue;
        const [key, val] = pair.split("=");
        result[key] = val;
      }

      return {
        identity: Identities.object,
        value: result as T
      };
    } else if (value.match(/^[0-9a-z]+\[\d+\]=.+$/)) {
      // Handle single array element case (e.g., "x[0]=1")
      const [, index, val] = value.match(/^[0-9a-z]+\[(\d+)\]=(.+)$/) || [];
      if (index !== undefined && val !== undefined) {
        const result = [];
        const marshalled = marshal(val);
        result[parseInt(index, 10)] = marshalled.value;
        return {
          identity: Identities.array,
          value: result as T
        };
      }
    } else if (value.match(/^[0-9a-z]+\[\]$/)) {
      return {
        identity: Identities.array,
        value: value as T
      };
    }

    // If the value is a string that is not a number, we check if it's a boolean:
    if (value.match(/^true$/i)) {
      return {
        identity: Identities.boolean,
        value: true as T
      };
    }
    if (value.match(/^false$/i)) {
      return {
        identity: Identities.boolean,
        value: false as T
      };
    }

    return {
      identity: Identities.string,
      value: value as T
    };
  } else if (typeof value === "number") {
    return {
      identity: Identities.number,
      value: value as T
    };
  } else if (value instanceof RegExp) {
    return {
      identity: Identities.regexp,
      value: value as T
    };
  } else if (typeof value === "boolean") {
    return {
      identity: Identities.boolean,
      value: value as T
    };
  } else if (value === null) {
    return {
      identity: Identities.null,
      value: null
    };
  } else if (value === undefined) {
    return {
      identity: Identities.undefined,
      value: undefined
    };
  } else if (Array.isArray(value)) {
    return {
      identity: Identities.array,
      value: value as T
    };
  } else if (typeof value === "object") {
    const marshalled = Object.entries(value).reduce(
      (acc, [key, val]) => {
        acc[key] = marshal(val)?.value;
        return acc;
      },
      {} as Record<string, unknown>
    );
    return {
      identity: Identities.object,
      value: marshalled as T
    };
  } else if (typeof value === "function") {
    return {
      identity: Identities.function,
      value: value as T
    };
  } else if (value instanceof Promise) {
    return {
      identity: Identities.promise,
      value: value as T
    };
  }

  throw new Error(
    `unable to marshal value: ${value} (it is neither a string, number, boolean, nor a regular expression)`
  );
};



---
File: /src/lib/helpers/normalize.ts
---

/**
 * Normalize a path to ensure it starts with a slash.
 *
 * @param {string} path The path to normalize.
 *
 * @returns {string} The normalized path.
 *
 * @category Helpers
 */
export const normalize = (path: string): string => {
  if (path && !path.startsWith("/")) {
    path = "/" + path;
  }
  return path;
};



---
File: /src/lib/helpers/objects.ts
---

/**
 * Convert a value to a primitive value.
 *
 * @param obj - The value to convert.
 *
 * @returns The primitive value.
 *
 * @category Helpers
 *
 */
export const toPrimitive = (obj: any): string | number | boolean | undefined | null | Array<any> => {
  if (obj instanceof RegExp) {
    return obj.toString();
  }
  if (obj instanceof Array) {
    return obj.map((item) => toPrimitive(item));
  }
  if (typeof obj === "object") {
    return Object.entries(obj).map(([key, value]) => {
      return {
        key,
        value: toPrimitive(value)
      };
    });
  }

  // Return the value as is if it's not an object, array, or RegExp.
  // TODO: Maybe we should throw an error here? (future mateo problem..)
  return obj;
};



---
File: /src/lib/helpers/query.ts
---

/**
 * Get a query parameter from the current URL.
 *
 * @param key - The key of the query parameter to get
 *
 * @returns The value of the query parameter, or null if it doesn't exist
 *
 * @category Helpers
 */
export const query = (key: string): string | null => {
  return new URLSearchParams(window.location.search).get(key);
};



---
File: /src/lib/helpers/regexp.ts
---

/**
 * Regular expression utilities.
 *
 * @module regexp
 * @category Helpers
 */
export namespace regexp {
  /**
   * Safely handle a capable value as a RegExp.
   *
   * If the value is a string, it will be converted to a RegExp.
   * If the value is already a RegExp, it will be returned as is.
   * Otherwise, an error will be thrown.
   *
   * @throws {Error} If the value is not a string or RegExp.
   */
  export const from = (v: string | RegExp): RegExp => {
    if (typeof v === "string") {
      return new RegExp(v);
    } else if (v instanceof RegExp) {
      return new RegExp(v.source);
    }
    throw new Error("invalid regexp expression");
  };

  /**
   * Check if a string contains regex syntax.
   *
   * @param v The string to check.
   * @returns True if the string contains regex syntax, false otherwise.
   */
  export const can = (v: string): boolean => {
    // Check for:
    // - Special characters: [] {} () * + ? . \ ^ $ |
    // - Character classes: \w \d \s and their negations
    // - Anchors: ^ $
    // - Quantifiers: + * ? {}
    // - Groups: (? (?: (?= (?! (?<= (?<!
    return /[[\]{}()*+?.,\\^$|#\s]|\\[wWdDsS]|\(\?[:!=<]?/.test(v);
  };
}



---
File: /src/lib/helpers/runtime.ts
---

import { logging } from "./logging";

/**
 * Runtime level configuration functionality.
 *
 * @category Helpers
 */
export namespace runtime {
  /**
   * Runtime configuration.
   */
  export type Config = {
    tracing: {
      enabled: boolean;
      level?: logging.LogLevel;
      console?: boolean;
      sink?: (...msg: logging.Log[]) => void | Promise<void>;
    };
    logging: {
      level?: logging.LogLevel;
      console?: boolean;
      sink?: (...msg: logging.Log[]) => void | Promise<void>;
    };
  };

  /**
   * Retrieve the runtime configuration.
   *
   * This can be sourced from environment variables or passed in as an argument.
   */
  export const config = (config?: Config): Config => {
    return {
      tracing: config?.tracing || import.meta?.env?.SPA_ROUTER?.tracing || false,
      logging: {
        level: config?.logging?.level || import.meta?.env?.SPA_ROUTER?.logging?.level || 4,
        console: config?.logging?.console || import.meta?.env?.SPA_ROUTER?.logging?.console,
        sink: config?.logging?.sink || import.meta?.env?.SPA_ROUTER?.logging?.sink
      }
    };
  };

  /**
   * The current runtime configuration.
   *
   * When first called, it will retrieve the runtime configuration from the environment variables.
   * After that, it can be mutated and will not be retrieved from the environment variables again.
   */
  export let current: Config = config();
}



---
File: /src/lib/helpers/tracing.svelte.ts
---

import { ReactiveMap } from "../utilities.svelte";

import { logging } from "./logging";
import { runtime } from "./runtime";

/**
 * A span is a single trace in a trace collection.
 *
 * @category Helpers
 */
export class Span {
  prefix?: string;
  id?: string;
  date?: Date;
  name?: string;
  description?: string;
  metadata?: Record<string, any>;
  traces?: ReactiveMap<string, Trace> = $state(new ReactiveMap());

  constructor(span: Span, prefix?: string) {
    this.prefix = prefix;
    this.name = span.name;
    this.id = span.id || Math.random().toString(36).substring(2, 25);
    this.description = span.description;
    this.metadata = span.metadata;
    this.date = span.date || new Date();
  }

  trace?(trace: Trace, prefix?: string): Trace {
    const id = trace.id || Math.random().toString(36).substring(2, 25);
    trace = new Trace(trace, this.traces.size + 1, this, prefix);
    this.traces.set(id, trace);

    logging.trace(prefix, trace);

    return trace;
  }

  get?(): MapIterator<Trace> {
    return this.traces.values();
  }
}

/**
 * A trace is a collection of spans.
 *
 * @category Helpers
 */
export class Trace {
  prefix?: string;
  id?: string;
  index?: number;
  date?: Date;
  name?: string;
  description?: string;
  metadata?: Record<string, any>;
  span?: Span;

  constructor(trace: Trace, index?: number, span?: Span, prefix?: string) {
    this.id = trace.id || Math.random().toString(36).substring(2, 25);
    this.index = index;
    this.date = trace.date || new Date();
    this.name = trace.name;
    this.description = trace.description;
    this.metadata = trace.metadata;
    this.span = span;
    this.prefix = trace.prefix;
  }

  /**
   * Wrapper method for logging a trace to the browser console.
   *
   * @category Helpers
   */
  toConsole?(level?: logging.LogLevel): void {
    const out = [
      "%c%s %cspan:%c%s:%ctrace:%c%s%c:%c%s %c%s",
      "color: #505050",
      this.date?.toISOString(),
      "color: #7A7A7A",
      "color: #915CF2; font-weight: bold",
      this.span?.name || this.id,
      "color: #7A7A7A; font-weight: bold",
      "color: #C3F53B; font-weight: bold",
      this.index,
      "color: #7A7A7A; font-weight: bold",
      "color: #3BAEF5; font-weight: bold",
      `${this.metadata?.router ? `[${this.metadata.router.id}] ` : ""}${this.name}`,
      "color: #06E96C",
      this.description
    ];

    if (this.prefix) {
      out[0] = `${this.prefix} %c%s %cspan:%c%s:%ctrace:%c%s%c:%c%s %c%s`;
    }

    if (runtime.current.tracing.level >= logging.LogLevel.TRACE) {
      out[0] += "\n%c%s";
      out.push(
        "color: #6B757F",
        `attached trace metadata:\n\n${JSON.stringify(
          {
            span: this.span.metadata,
            trace: this.metadata
          },
          null,
          2
        )}`
      );
    } else if (runtime.current.tracing.level >= logging.LogLevel.DEBUG) {
      if (this.span) {
        // @ts-ignore
        out.push(this.span.metadata);
      }
      if (this.metadata) {
        // @ts-ignore
        out.push(this.metadata);
      }
    }

    console.log(...out);
  }
}

/**
 * A reactive map of spans.
 *
 * @category Helpers
 */
export const spans = new ReactiveMap<string, Span>();

/**
 * Helper method for creating a new span.
 *
 * @category Helpers
 */
export const createSpan = (name: string, metadata?: Record<string, any>) => {
  if (runtime.current.tracing) {
    const span = new Span({ name, metadata });
    spans.set(name, span);
    return span;
  }
};



---
File: /src/lib/helpers/urls.test.ts
---

import { expect, test } from "vitest";

import { urls } from "./urls";

test.only("parses with no query parameters", () => {
  expect(urls.parse("http://localhost:5173/#/foo/bar")).toEqual({
    protocol: "http",
    host: "localhost",
    port: "5173",
    path: "/foo/bar",
    hash: "/foo/bar",
    query: {
      original: "",
      params: {}
    }
  });
});

test.only("parses key-value query parameters", () => {
  expect(urls.parse("http://localhost:5173/#/foo/bar?negative=-123&a=1&str=string&b=true")).toEqual({
    protocol: "http",
    host: "localhost",
    port: "5173",
    path: "/foo/bar",
    query: {
      params: {
        a: "1",
        str: "string",
        b: "true",
        negative: "-123"
      }
    },
    hash: "/foo/bar?negative=-123&a=1&str=string&b=true"
  });
});

// test.only("parses array parameter parsing", () => {
//   expect(urls.parse("http://localhost:5173/#/foo/bar?a[3]=3&a[19]=1.9&a[0]=first&a[99]=9.99&a[5]=false")).toEqual({
//     protocol: "http",
//     host: "localhost",
//     port: "5173",
//     path: "/foo/bar",
//     query: {
//       params: {
//         a: ["first", 3, false, 1.9, 9.99]
//       }
//     },
//     hash: "/foo/bar?a[3]=3&a[19]=1.9&a[0]=first&a[99]=9.99&a[5]=false"
//   });
// });

// test.only("query is undefined", () => {
//   expect(urls.parse("http://localhost:5173/foo/bar").query.toString()).toEqual("");
// });

// test.only("query.toString() matches location.search", () => {
//   expect(urls.parse("http://localhost:5173/foo/bar?a=1&b=2").query.toString()).toEqual("a=1&b=2");
//   expect(urls.parse("http://localhost:5173/#/foo/bar?a=1&b=2").query.toString()).toEqual("a=1&b=2");
// });

// test.only("query.toString() matches multiples (pagination=2,23&company=123)", () => {
//   expect(urls.parse("http://localhost:5173/foo/bar?pagination=2,23&company=123").query.toString()).toEqual(
//     "pagination=2,23&company=123"
//   );
//   expect(urls.parse("http://localhost:5173/#/foo/bar?pagination=2,23&company=123").query.toString()).toEqual(
//     "pagination=2,23&company=123"
//   );
// });



---
File: /src/lib/helpers/urls.ts
---

import { hash, type Hash } from "../hash";
import { Query } from "../query.svelte";

import { normalize } from "./normalize";

/**
 * The returned param value types for paths.
 *
 * @remarks
 * Multiple types are supported to allow for flexibility in the
 * types of params such as when an evaluation uses regex with match grouping.
 *
 * Every param value is a string, array of string, or a record
 * of string keys and values.
 *
 * Params are extracted and converted to the appropriate type
 * later in the route lifecycle
 *
 * @category Router
 */
export type Param = string | number | boolean;

/**
 * The returned param value types.
 *
 * @remarks
 * Multiple types are supported to allow for flexibility in the
 * types of params such as when an evaluation uses regex with match grouping.
 *
 * Every param value is a string, array of string, or a record
 * of string keys and values.
 *
 * Params are extracted and converted to the appropriate type
 * later in the route lifecycle
 *
 * @category Router
 */
export type ReturnParam =
  | RegExp
  | boolean
  | boolean[]
  | number
  | number[]
  | string
  | string[]
  | Record<string, string | number | boolean | string[] | number[] | boolean[]>;

export type URL = {
  protocol: string;
  host: string;
  port: string;
  path: string;
  query: Query;
  hash: Hash;
};

export namespace urls {
  /**
   * Parse a URL string into its components
   * @param url The URL to parse
   * @returns Object containing path, query params, and hash components
   */
  export const parse = (url: string): URL => {
    if (url === undefined || url.length === 0) {
      throw new Error(`invalid URL: ${url}`);
    }
    const isAbsoluteUrl = url.includes("://");
    if (isAbsoluteUrl) {
      const [protocol, remaining] = url.split("://");
      const hostPortMatch = remaining.match(/^([^/:]+)(?::(\d+))?(.*)$/);
      const [host, port, path] = hostPortMatch?.slice(1) ?? [];

      const [before, queryString = ""] = (path || "").split("?");
      const hashed = hash.parse(url);

      return {
        protocol,
        host,
        port,
        path: normalize(before) || "/",
        query: new Query(queryString),
        hash: hashed
      };
    } else {
      // Handle relative URLs
      const [pathPart, queryString = ""] = url.split("?");
      const hashed = hash.parse(url);

      return {
        protocol: window.location.protocol.replace(":", ""),
        host: window.location.hostname,
        port: window.location.port,
        path: normalize(pathPart) || "/",
        query: new Query(queryString),
        hash: hashed
      };
    }
  };

  export const path = (path: string): string => {
    return path.split("?")[0];
  };
}



---
File: /src/lib/hash.test.ts
---

// import { describe, expect, test } from "vitest";

// import { hash } from "./hash";

// describe("simple params", () => {
//   test("simple params", () => {
//     expect(hash.parse("/foo/bar?negative=-123&a=1&str=string&b=true")).toEqual({
//       path: "/foo/bar",
//       query: {
//         params: {
//           a: 1,
//           str: "string",
//           b: true,
//           negative: -123
//         }
//       },
//       hash: "/foo/bar?negative=-123&a=1&str=string&b=true"
//     });
//   });
// });

// describe("crazy params", () => {
//   test("crazy params", () => {
//     expect(hash.parse("/#/foo/bar?a[3]=3&a[19]=1.9&a[0]=first&a[99]=9.99&a[5]=false")).toEqual({
//       path: "/foo/bar",
//       query: {
//         params: {
//           a: ["first", 3, false, 1.9, 9.99]
//         }
//       },
//       hash: "/foo/bar?a[3]=3&a[19]=1.9&a[0]=first&a[99]=9.99&a[5]=false"
//     });
//   });
// });



---
File: /src/lib/hash.ts
---

import { Query } from "./query.svelte";

export type Hash = {
  path: string;
  query: Query;
  hash: string;
};

export namespace hash {
  /**
   * Parse a URL string into its components
   * @param url The URL to parse
   * @returns Object containing path, query params, and hash components
   */
  export const parse = (url: string): Hash => {
    if (url) {
      const [_, afterHash = ""] = url.split("#");
      const [path, queryString = ""] = afterHash.split("?");
      return {
        path,
        query: new Query(queryString),
        hash: afterHash
      };
    }
  };
}



---
File: /src/lib/hooks.ts
---

import type { RouteResult } from "./route.svelte";

/**
 * Hooks are functions that can be used to modify the behavior of routing
 * when a route is navigated to (before and/or after).
 *
 * The return value of the hook is a boolean that determines if the route should
 * be navigated to. If the hook returns `false` (or nothing), navigation will be cancelled.
 *
 * @category hooks
 */
export type HookReturn = void | boolean | Promise<boolean> | Promise<void>;
export type Hook = (route: RouteResult) => HookReturn;



---
File: /src/lib/index.ts
---

export * from "./actions";
export { active } from "./actions/active.svelte";
export { RouteOptions } from "./actions/options";
export { route } from "./actions/route.svelte";
export * from "./helpers";
export type { Condition, Evaluation, EvaluationResult } from "./helpers/evaluators";
export { goto } from "./helpers/goto";
export { identify, type Identities, type Identity } from "./helpers/identify";
export { logging } from "./helpers/logging";
export { marshal, type Marshalled } from "./helpers/marshal";
export { normalize } from "./helpers/normalize";
export { query } from "./helpers/query";
export { runtime } from "./helpers/runtime";
export { Span, Trace } from "./helpers/tracing.svelte";
export type { ReturnParam as Param } from "./helpers/urls";
export type { Hook } from "./hooks";
export { Query } from "./query.svelte";
export type { QueryEvaluationResult, QueryType } from "./query.svelte";
export { registry, type Registry } from "./registry.svelte";
export type { ApplyFn, Route, RouteConfig, RouteResult } from "./route.svelte";
export { RouterInstanceConfig } from "./router-instance-config";
export { RouterInstance } from "./router-instance.svelte";
export { default as Router } from "./router.svelte";
export { getStatusByValue, StatusCode, type Statuses } from "./statuses";



---
File: /src/lib/path.ts
---

/**
 * @remarks
 * Future home of more path related functionality.
 */
import { Query } from "./query.svelte";

/**
 * The types of values that can be used as a path.
 *
 * @category Router
 */
export type PathType = string | number | RegExp | Function | Promise<unknown>;

export class Path {
  protocol: string;
  host: string;
  path: string;
  query: Query;

  constructor() {
    this.protocol = location.protocol;
    this.host = location.host;
    this.path = location.pathname;
    if (location.search.length > 0) {
      this.query = new Query(Object.fromEntries(new URLSearchParams(location.search)));
    }
  }

  toURL(): string {
    return `${this.protocol}://${this.host}${this.path}${this.query ? this.query.toString() : ""}`;
  }

  toURI(): string {
    return `${this.path}${this.query ? this.query.toString() : ""}`;
  }
}

export namespace paths {
  export const base = (base: string, path: string): boolean => {
    return path.match(new RegExp(`^${base}(/|$)`)) !== null;
  };
}



---
File: /src/lib/query.svelte.ts
---

import { evaluators, type Condition } from "./helpers/evaluators";
import { goto } from "./helpers/goto";
import { Identities } from "./helpers/identify";
import { marshal } from "./helpers/marshal";
import type { ReturnParam } from "./helpers/urls";

/**
 * The types of values that can be used as a query.
 *
 * @category Router
 */
export type QueryType<T = unknown> = Record<string, string | number | RegExp | Function | Promise<T>>;

/**
 * The types of values that the {Query} test method can return.
 *
 * @category Router
 */
export type QueryEvaluationResult = {
  condition: Condition;
  matches?: Record<string, ReturnParam>;
};

/**
 * Query string operations.
 *
 * @category Helpers
 */
export class Query {
  params: Record<string, ReturnParam> = {};
  original?: string;

  constructor(query?: Record<string, string> | string | Query | Record<string, ReturnParam>) {
    if (typeof query === "string") {
      this.original = query;
    }

    if (query) {
      const marshalled = marshal(query);
      if (marshalled.value) {
        this.params = marshalled.value as Record<string, ReturnParam>;
      }
    }
  }

  /**
   * Get a value from the query string parameters and optionally provide
   * a default value if the key is not found.
   *
   * @param key - The key to get the value from.
   * @param defaultValue - The default value to return if the key is not found.
   */
  get<T>(key: string, defaultValue?: T): T {
    return (this.params[key] as T) || defaultValue;
  }

  /**
   * Set a value in the query string parameters.
   */
  set(key: string, value: string) {}

  /**
   * Delete a value from the query string parameters.
   */
  delete(key: string) {
    delete this.params[key];
  }

  /**
   * Clear the query string parameters.
   */
  clear() {
    this.params = {};
  }

  goto(path: string) {
    goto(path, this.params);
  }

  test(inbound: Query): QueryEvaluationResult {
    if (typeof inbound === "object") {
      const matches: Record<string, ReturnParam> = {};
      for (const [key, test] of Object.entries(inbound.params)) {
        if (this.params[key]) {
          const marshalled = marshal(this.params[key]);
          if (test instanceof RegExp) {
            const res = evaluators.any[Identities.regexp](test, this.params[key]);
            if (res) {
              matches[key] = res;
            } else {
              return {
                condition: "no-match"
              };
            }
          } else if (marshalled.identity === Identities.number) {
            if (marshalled.value === this.params[key]) {
              matches[key] = marshalled.value as number;
            }
          } else if (marshalled.identity === Identities.string) {
            matches[key] = marshalled.value === this.params[key];
          } else if (marshalled.identity === Identities.boolean) {
            matches[key] = marshalled.value === Boolean(this.params[key]);
          } else if (marshalled.identity === Identities.array) {
            matches[key] = (marshalled.value as Array<unknown>).includes(this.params[key]);
          }
        } else {
          return {
            condition: "no-match"
          };
        }
      }

      if (Object.keys(matches).length === Object.keys(inbound).length && evaluators.valid[Identities.object](matches)) {
        return {
          condition: "exact-match",
          matches: marshal(matches).value as Record<string, ReturnParam>
        };
      }

      return {
        condition:
          Object.keys(matches).length > 1 && Object.keys(inbound).length !== Object.keys(matches).length
            ? "exact-match"
            : "no-match",
        matches: matches as Record<string, ReturnParam>
      };
    }
  }

  /**
   * Convert the query string parameters to a string.
   */
  toString() {
    const stringifyValue = (value: any): string => {
      if (Array.isArray(value)) {
        return value.map((v) => stringifyValue(v)).join(",");
      }
      if (typeof value === "object" && value !== null) {
        return Object.entries(value)
          .map(([k, v]) => `${k}:${stringifyValue(v)}`)
          .join(",");
      }
      // console.log("stringifyValue", value, typeof value);
      return encodeURIComponent(value);
    };

    return Object.entries(this.params)
      .map(([key, value]) => `${encodeURIComponent(key)}=${stringifyValue(value)}`)
      .join("&");
    // return preserveOriginal ? this._original : "";
  }

  /**
   * Convert the query string parameters to a JSON object given
   * we may have parameter values that are not json serializable
   * out of the box.
   */
  toJSON(preserveOriginal?: boolean) {
    return Object.fromEntries(Object.entries(this.params).map(([key, value]) => [key, value.toString()]));
  }
}



---
File: /src/lib/query.test.ts
---

import { describe, expect, test } from "vitest";

import { Query } from "./query.svelte";

describe("query", () => {
  test("should create a query object from a string", () => {
    expect(new Query("b=2&a=false&c=str").params).toEqual({ a: false, b: 2, c: "str" });
  });

  test("should create a query object from a string", () => {
    expect(new Query("nonarray=1&a[3]=3&a[19]=1.9&a[0]=first&a[99]=9.99&a[5]=false").params).toEqual({
      nonarray: 1,
      a: ["first", 3, false, 1.9, 9.99]
    });
  });
});



---
File: /src/lib/registry.svelte.ts
---

import type { ApplyFn } from "./route.svelte";
import { RouterInstanceConfig } from "./router-instance-config";
import { RouterInstance } from "./router-instance.svelte";
import { ReactiveMap } from "./utilities.svelte";

import type { Span } from "./helpers/tracing.svelte";

/**
 * Handles the dynamic registration and deregistration of router instances.
 *
 * @remarks
 * This is a singleton and should not be instantiated directly.
 *
 * @category Registry
 */
export class Registry {
  /**
   * Container for router instances.
   */
  instances = new ReactiveMap<string, RouterInstance>();

  constructor() {
    // Prevent multiple instantiation during HMR by storing instance in window
    if ((window as any).__SVELTE_SPA_ROUTER_REGISTERED__) {
      return (window as any).__SVELTE_SPA_ROUTER_REGISTERED__;
    }
    (window as any).__SVELTE_SPA_ROUTER_REGISTERED__ = this;

    const { pushState, replaceState } = window.history;

    window.history.pushState = function (...args) {
      pushState.apply(window.history, args);
      window.dispatchEvent(new Event("pushState"));
    };

    window.history.replaceState = function (...args) {
      replaceState.apply(window.history, args);
      window.dispatchEvent(new Event("replaceState"));
    };
  }

  /**
   * Register a new router instance.
   *
   * @param {Instance} config The instance to register.
   * @param {ApplyFn} applyFn The function to call for applying route changes.
   *
   * @see {@link deregister}: The opposite of this method.
   */
  register(config: RouterInstanceConfig, applyFn: ApplyFn, span?: Span): RouterInstance {
    if (this.instances.has(config.id)) {
      throw new Error(`router instance with id ${config.id} already registered`);
    }

    const instance = new RouterInstance(config, applyFn);

    if (span) {
      span.trace({
        prefix: "🔍",
        name: "registry.register",
        description: "registering a new router instance",
        metadata: {
          router: {
            id: config.id,
            basePath: config.basePath
          },
          location: "/src/lib/registry.svelte:register()",
          config
        }
      });
    }

    this.instances.set(config.id, instance);

    return instance;
  }

  /**
   * Deregister a router instance.
   *
   * @param {string} id The id of the instance to deregister.
   */
  deregister(id: string, span?: Span): void {
    const instance = this.instances.get(id);
    if (span) {
      span.trace({
        prefix: instance ? "✅" : "❌",
        name: "registry.deregister",
        description: "deregistering a router instance",
        metadata: {
          router: {
            id,
            basePath: instance.config.basePath
          },
          location: "/src/lib/registry.svelte:deregister()",
          config: instance.config
        }
      });
    }

    if (instance) {
      this.instances.delete(id);
    } else {
      throw new Error(`router instance with id ${id} not found`);
    }
  }

  get(id: string): RouterInstance {
    const instance = this.instances.get(id);

    return instance;
  }
}

/**
 * Expose a reference to the registry of router instances.
 *
 * This is used to register & unregister router instances and to get
 * the route for a given path.
 *
 * This is a singleton and should not be instantiated directly and should
 * never be accessed outside of the scope of this package in most cases.
 *
 * @category Registry
 */
export const registry = (window as any).__SVELTE_SPA_ROUTER_REGISTRY__ || new Registry();



---
File: /src/lib/route.svelte.ts
---

/**
 * This is the doc comment for file1.ts
 *
 * @packageDocumentation
 */
import type { Component, Snippet } from "svelte";

import type { Hook } from "./hooks";
import { paths, type PathType } from "./path";
import { Query } from "./query.svelte";

import { evaluators, type Condition, type Evaluation } from "./helpers/evaluators";
import { Identities } from "./helpers/identify";
import { marshal } from "./helpers/marshal";
import { normalize } from "./helpers/normalize";
import { regexp } from "./helpers/regexp";
import type { Span, Trace } from "./helpers/tracing.svelte";
import { urls, type ReturnParam } from "./helpers/urls";

/**
 * A route result that includes the evaluation results of the route.
 *
 * This type is necessary for the internal workings of the router to ensure that
 * the evaluation results are included in the route result and to avoid requiring
 * it to be merged in the original route instance.
 *
 * @since 2.0.0
 * @category Router
 * @example
 * ```ts
 * const routeResult = new RouteResult({
 *   router: myRouter,
 *   route: myRoute,
 *   result: {
 *     path: {
 *       condition: "exact-match",
 *       original: "/users/123",
 *       params: { id: "123" }
 *     },
 *     querystring: {
 *       condition: "exact-match",
 *       original: { filter: "active" },
 *       params: { filter: "active" }
 *     },
 *     component: UserComponent,
 *     status: 200
 *   }
 * });
 * ```
 */
export class RouteResult {
  /**
   * The route that was evaluated to render this result.
   *
   * @since 2.0.0
   * @readonly
   * @remarks This may be undefined if the route result was created without an associated route.
   * @see {@link Route}
   */
  route?: Route;

  /**
   * The comprehensive result of routing evaluation that rendered this route.
   *
   * This object contains all the information gathered during the route matching process,
   * including path evaluation, querystring parsing, component resolution, and status determination.
   *
   * @since 2.0.0
   * @readonly
   * @remarks The result object is immutable once created and represents a snapshot of the routing state.
   *
   * @example
   * ```ts
   * // Accessing route evaluation results
   * console.log(routeResult.result.path.original); // "/users/123"
   * console.log(routeResult.result.path.params?.id); // "123"
   * console.log(routeResult.result.status); // 200
   * ```
   */
  result: {
    /**
     * The path evaluation results containing the matched path information.
     *
     * This object provides detailed information about how the current URL path
     * was matched against the route's path pattern, including any extracted parameters.
     *
     * @since 2.0.0
     * @example
     * ```ts
     * // For a route with path "/users/:id" and URL "/users/123"
     * const pathResult = {
     *   condition: "exact-match",
     *   original: "/users/123",
     *   params: { id: "123" }
     * };
     * ```
     */
    path: {
      /**
       * The evaluation condition indicating how the path was matched.
       *
       * @since 2.0.0
       * @see {@link Condition} For available condition types
       * @example "exact-match" | "base-match" | "no-match"
       */
      condition: Condition;

      /**
       * The original path string that was evaluated during routing.
       *
       * This represents the actual path portion of the URL that was processed,
       * without query parameters or hash fragments.
       *
       * @since 2.0.0
       * @example "/users/123/profile"
       * @remarks This path is normalized and may differ from the raw URL path
       */
      original: string;

      /**
       * The parameters extracted from the path during evaluation.
       *
       * Contains named parameters extracted from the path pattern matching,
       * such as route parameters defined with `:paramName` syntax or regex groups.
       *
       * @since 2.0.0
       * @default undefined
       * @example
       * ```ts
       * // For route "/users/:id" matching "/users/123"
       * params: { id: "123" }
       *
       * // For regex route "^/posts/(?<slug>.+)$" matching "/posts/my-article"
       * params: { slug: "my-article" }
       * ```
       * @see {@link ReturnParam} For parameter value types
       * @remarks This is undefined when no parameters are extracted from the path
       */
      params?: ReturnParam;
    };

    /**
     * The querystring evaluation results containing parsed query parameters.
     *
     * This object provides information about how the URL's query string
     * was processed and any parameters that were extracted or matched.
     *
     * @since 2.0.0
     * @example
     * ```ts
     * // For URL "?filter=active&page=2"
     * const querystringResult = {
     *   condition: "exact-match",
     *   original: { filter: "active", page: "2" },
     *   params: { filter: "active", page: "2" }
     * };
     * ```
     */
    querystring: {
      /**
       * The evaluation condition indicating how the querystring was matched.
       *
       * @since 2.0.0
       * @see {@link Condition} For available condition types
       * @example "exact-match" | "partial-match" | "no-match"
       */
      condition: Condition;

      /**
       * The original querystring data that was evaluated during routing.
       *
       * This can be either a parsed object representation of query parameters
       * or the raw querystring, depending on how the route was configured.
       *
       * @since 2.0.0
       * @see {@link ReturnParam} For supported parameter types
       * @example
       * ```ts
       * // Parsed object format
       * original: { filter: "active", sort: "name" }
       *
       * // Raw string format
       * original: "filter=active&sort=name"
       * ```
       */
      original: ReturnParam;

      /**
       * The parameters extracted from the querystring during evaluation.
       *
       * Contains the processed query parameters after applying any route-specific
       * querystring matching rules and transformations.
       *
       * @since 2.0.0
       * @default undefined
       * @see {@link ReturnParam} For parameter value types
       * @example
       * ```ts
       * // Standard query parameters
       * params: { search: "term", page: "1" }
       *
       * // With type conversion
       * params: { page: 1, active: true }
       * ```
       * @remarks This may be undefined if no querystring processing was required
       */
      params?: ReturnParam;
    };

    /**
     * The component that was resolved and rendered when the route became active.
     *
     * This represents the actual component instance, snippet, or component factory
     * that was determined during the routing process. It can be a direct component
     * reference, a lazy-loaded component function, or a Svelte snippet.
     *
     * @since 2.0.0
     * @default undefined
     * @see {@link Component} Svelte component type
     * @see {@link Snippet} Svelte snippet type
     * @example
     * ```ts
     * // Direct component reference
     * component: UserProfile
     *
     * // Lazy-loaded component
     * component: () => import('./UserProfile.svelte')
     *
     * // Svelte snippet
     * component: mySnippet
     * ```
     * @remarks This is undefined when the route doesn't render a component directly,
     * such as when using hooks for custom rendering logic
     */
    component?: Component<any> | Snippet | (() => Promise<Component<any> | Snippet>) | Function | any;

    /**
     * The HTTP-style status code representing the result of the routing operation.
     *
     * This numeric code indicates the outcome of the route evaluation process,
     * following HTTP status code conventions for consistency and familiarity.
     * The status helps determine how the route result should be handled by
     * status handlers and middleware.
     *
     * @since 2.0.0
     * @see {@link StatusCode} For predefined status code constants
     * @see {@link Statuses} For status-specific handlers
     * @example
     * ```ts
     * status: 200  // Successful route match
     * status: 404  // Route not found
     * status: 401  // Unauthorized access
     * status: 500  // Internal routing error
     * ```
     * @remarks Common values include 200 (OK), 404 (Not Found), 401 (Unauthorized),
     * 403 (Forbidden), and 500 (Internal Server Error)
     */
    status: number;
  };

  /**
   * The constructor for the `RouteResult` class.
   *
   * @param result The result of the route evaluation.
   */
  constructor(result: RouteResult) {
    this.route = result.route;
    this.result = result.result;
  }

  /**
   * The string representation of the route including the querystring.
   */
  toString?(): string {
    let querystring = "";
    if (this.result.querystring.original && typeof this.result.querystring.original === "object") {
      const params = new URLSearchParams();
      for (const [key, value] of Object.entries(this.result.querystring.original)) {
        if (value !== undefined && value !== null) {
          params.append(key, String(value));
        }
      }
      querystring = params.toString();
    } else if (this.result.querystring.original) {
      querystring = String(this.result.querystring.original);
    }

    return `${this.result.path.original}${querystring ? `?${querystring}` : ""}`;
  }
}

/**
 * The function that is used to apply a route to the DOM.
 *
 * @category Router
 */
export type ApplyFn = (result: RouteResult, span?: Span) => void;

/**
 * The function that is used to apply a route to the DOM.
 *
 * @category Router
 */
export type ApplyFn2 = (result: RouteResult, span?: Span) => void;

/**
 * A generic type that can be used to test the type of a value.
 * @category Router
 * @example
 * ```ts
 * const a: Testing<string> = "asdf";
 * const b: Testing<number> = 123;
 * ```
 */
export type Testing<T> = T;

export class RouteConfig {
  name?: string | number;
  basePath?: string;
  path?: PathType;
  querystring?: Record<string, ReturnParam>;
  component?: Component<any> | Snippet | (() => Promise<Component<any> | Snippet>) | Function | any;
  props?: Record<string, any>;
  hooks?: {
    pre?: Hook | Hook[];
    post?: Hook | Hook[];
  };
  children?: RouteConfig[];
  status?: number;

  constructor(config: RouteConfig) {
    this.name = config.name;
    this.basePath = config.basePath;
    this.path = config.path;
    this.querystring = config.querystring;
    this.component = config.component;
    this.props = config.props;
    this.hooks = config.hooks;
    this.status = config.status;
  }

  toJSON?(): any {
    return {
      name: this.name,
      basePath: this.basePath,
      path: this.path,
      props: this.props,
      component: this.component,
      querystring: this.querystring,
      hooks: this.hooks,
      children: this.children,
      status: this.status
    };
  }
}

/**
 * A route that can be navigated to.
 * @example
 * ```ts
 * const routes: Route[] = [
 *   {
 *     component: Home
 *   },
 *   {
 *      path: "(?<child>.*)",
 *      component: ParseRouteParams
 *   }
 * ]
 * ```
 *
 * @category Router
 */
export class Route {
  /**
   * The unique identifier of this route.
   * This is useful if you need to track routes outside of the router's scope.
   *
   * @optional If no value is provided, the route will not have a name.
   */
  name?: string | number;

  /**
   * The base path of the route.
   *
   * This is useful if you want to be declarative about the base path of the route
   * and not depend on the router to determine the base path.
   */
  basePath?: string;

  /**
   * The path of the route to match against the current path.
   *
   * @optional If not provided, the route will match any path
   * as it will be the default route.
   */
  path?: PathType;

  /**
   * The query params of the route.
   *
   * @optional If no value is provided, there are no query params.
   */
  querystring?: Query;

  /**
   * The component to render when the route is active.
   *
   * @optional If no value is provided, the route will not render a component.
   * This is useful if you want to use pre or post hooks to render a component
   * or snippet conditionally.
   */
  component?: Component<any> | Snippet | (() => Promise<Component<any> | Snippet>) | Function | any;

  /**
   * The props to pass to the component.
   *
   * @optional If a value is provided, the component will receive this value in $props().
   */
  props?: Record<string, any>;

  /**
   * Hooks to be run before and after the routes are rendered
   * at the router level (independent of the route hooks if applicable).
   *
   * @optional If no value is provided, no hooks will be run.
   */
  hooks?: {
    pre?: Hook | Hook[];
    post?: Hook | Hook[];
  };

  /**
   * The children routes of the route.
   *
   * This is useful if you want to be declarative about the routes that are direct
   * children of this route and not depend on the router to determine the children
   * when there are multiple <Router/> instances.
   *
   *
   * @optional If no value is provided, there are no direct child routes. Routes may
   * be mapped to children routes by the router when there are multiple <Router/> instances
   * with overlapping `basePath` values.
   *
   * @example
   * ```ts
   * const routes: Route[] = [
   *   ...
   *   {
   *     path: "/users",
   *     children: [
   *       {
   *         path: "/:id",
   *         component: User
   *       }
   *     ]
   *   }
   *   ...
   * ]
   * ```
   */
  children?: Route[];

  /**
   * The status of the route once it has been matched or otherwise processed.
   */
  status?: number;

  /**
   * Traces are a list of objects that describe the route's path and query params
   * as it is processed by the router.
   */
  traces?: Trace[] = $state([]);

  /**
   * The constructor for the `Route` class.
   *
   * @param {Route} config An instance of the `Route` class.
   */
  constructor(config: RouteConfig) {
    this.name = config.name;
    this.basePath = config.basePath;
    this.path = typeof config.path === "string" ? normalize(config.path) : config.path;

    if (config.querystring) {
      this.querystring = new Query(config.querystring);
    }

    this.component = config.component;
    this.props = config.props;
    this.hooks = config.hooks;
    this.status = config.status;
    this.children = config.children?.map((child) => new Route(child));
  }

  /**
   * Parse the route against the given path.
   * @param path The path to parse against the route.
   */
  test?(path: PathType): Evaluation {
    const matcher = urls.path(path.toString());
    // Handle string paths being passed in at the route.path level:
    if (typeof this.path === "string") {
      // Detect if this path contains regex syntax:
      if (regexp.can(this.path)) {
        // Path is a regex, so we need to test it against the path passed in:
        const match = regexp.from(this.path).exec(matcher);
        if (match) {
          return {
            condition: "exact-match",
            params: match.groups
          };
        }
      } else {
        // Path is not a regex, so we then check if the path passed in is a direct match:
        if (this.path === matcher) {
          return {
            condition: "exact-match",
            params: this.path
          };
        } else if (paths.base(this.path, matcher)) {
          return {
            condition: "base-match",
            params: {}
          };
        }
      }
    }
    // Handle RegExp instances being passed in at the route.path level:
    else if (this.path instanceof RegExp) {
      const res = evaluators.any[Identities.regexp](this.path, matcher);
      if (res) {
        return {
          condition: "exact-match",
          params: res
        };
      }
    }
    // Handle numeric paths being passed in at the route.path level:
    else if (typeof this.path === "number" && this.path === marshal(matcher).value) {
      throw new Error("numbered route match not supported at the route.path level");
    }

    return {
      condition: "no-match",
      params: {}
    };
  }

  /**
   * The absolute path of the route by combining the router's base path and
   * the route's path.
   */
  absolute?(): string {
    /**
     * If the router has a base path, we need to combine it with the route's path
     * otherwise it will have "undefined" as the base path and the path will be
     * incorrect:
     */
    if (this.basePath) {
      return `${this.basePath}${this.path}`;
    }
    return this.path.toString();
  }
}



---
File: /src/lib/router-instance-config.ts
---

import { type Component } from "svelte";

import type { Hook } from "./hooks";
import { RouteConfig } from "./route.svelte";
import type { Statuses } from "./statuses";

/**
 * The configuration for a new router instance.
 *
 * @remarks
 * This class should rarely be used directly. Instead, use the `Router` component
 * to create a new router instance.
 *
 * @category Router
 */
export class RouterInstanceConfig {
  /**
   * The id for the router instance.
   *
   * @optional If no value is provided, the id will be a random string of characters.
   */
  id?: string;

  /**
   * The base path for the router instance.
   *
   * @optional If no value is provided, the base path will be "/".
   */
  basePath?: string;

  /**
   * The routes for the router instance.
   */
  routes: RouteConfig[];

  /**
   * Hooks to be run before and after the routes are rendered
   * at the router level (independent of the route hooks if applicable).
   *
   * @optional If no value is provided, no hooks will be run.
   */
  hooks?: {
    pre?: Hook | Hook[];
    post?: Hook | Hook[];
  };

  /**
   * The initial path for the router instance.
   *
   * @optional If no value is provided, the initial path will be the current path of the browser.
   */
  initialPath?: string;

  /**
   * The not found component for the router instance.
   *
   * @optional If no value is provided and no route could be found,
   * the router will will not render anything.
   */
  notFoundComponent?: Component<any>;

  /**
   * The default components rendered when a route is not found and
   * the status code is in one of the following:
   * 400, 401, 403, 404, 500
   * @optional If no value is provided, the default components will not be rendered.
   */
  statuses?: Statuses;

  /**
   * Whether to allow the same route to be rendered if the conditions are the
   * same (taking in to account the path, query, and status code).
   */
  renavigation?: boolean;

  /**
   * The constructor for this router instance.
   *
   * @param {RouterInstanceConfig} config The config for this router instance.
   */
  constructor(config: RouterInstanceConfig) {
    this.id = config.id || Math.random().toString(36).substring(2, 15);
    this.basePath = config.basePath;
    this.hooks = config.hooks;
    this.initialPath = config.initialPath;
    this.notFoundComponent = config.notFoundComponent;
    this.statuses = config.statuses;
    this.routes = config.routes.map(
      (route) =>
        new RouteConfig({
          ...route,
          ...config
        })
    );
  }

  toJSON(): any {
    return {
      id: this.id,
      basePath: this.basePath,
      routes: this.routes,
      hooks: this.hooks
    };
  }
}



---
File: /src/lib/router-instance.svelte.ts
---

import { Query, registry, RouterInstanceConfig, Span, type ApplyFn, type Hook } from ".";
import { Route, RouteResult } from "./route.svelte";
import { StatusCode } from "./statuses";
import { execute } from "./utilities.svelte";

import { SuccessfulConditions } from "./helpers/evaluators";
import { normalize } from "./helpers/normalize";
import { createSpan } from "./helpers/tracing.svelte";
import { urls } from "./helpers/urls";

/**
 * The default routes that are used when no routes match.
 *
 * @category Router
 */
export const defaultRoutes = ["", "/", "/*", "/^.*$/", "/.*/"];

/**
 * The handlers type that is used when registering a router instance.
 *
 * This is used to restore the original history methods when the last instance is destroyed
 * and to register & unregister the event listeners for the router instances to prevent memory leaks.
 *
 * @category Router
 */
export type RouterHandlers = {
  /**
   * The handler for the pushState event.
   */
  pushStateHandler: () => void;

  /**
   * The handler for the replaceState event.
   */
  replaceStateHandler: () => void;

  /**
   * The handler for the popState event.
   */
  popStateHandler: () => void;

  /**
   * The handler for the hashchange event.
   */
  hashChangeHandler: () => void;
};

/**
 * A class that represents a router instance.
 *
 * @remarks
 * This class should rarely be used directly. Instead, use the `Router` component
 * to create a new router instance.
 *
 * @category Router
 */
export class RouterInstance {
  /**
   * The id of the router instance.
   */
  id: string;

  /**
   * The routes for the router instance.
   */
  routes = new Set<Route>();

  /**
   * The handlers for the router instance.
   */
  handlers: RouterHandlers;

  /**
   * The config for the router instance.
   */
  config: RouterInstanceConfig;

  /**
   * The apply function for the router instance.
   */
  applyFn: ApplyFn;

  /**
   * Whether the router instance is navigating.
   */
  navigating = $state(false);

  /**
   * The current route for the router instance.
   */
  current = $state<RouteResult>();

  /**
   * The constructor for the RouterInstance class.
   *
   * @param {RouterInstanceConfig} config The config for the router instance.
   * @param {ApplyFn} applyFn The apply function for the router instance.
   */
  constructor(config: RouterInstanceConfig, applyFn: ApplyFn) {
    this.id = config.id || Math.random().toString(36).substring(2, 15);
    this.config = config;
    this.applyFn = applyFn;

    this.handlers = {
      pushStateHandler: () => this.handleStateChange(location.toString()),
      replaceStateHandler: () => this.handleStateChange(location.toString()),
      popStateHandler: () => this.handleStateChange(location.toString()),
      hashChangeHandler: () => this.handleStateChange(location.toString())
    };

    window.addEventListener("pushState", this.handlers.pushStateHandler);
    window.addEventListener("replaceState", this.handlers.replaceStateHandler);
    window.addEventListener("popstate", this.handlers.popStateHandler);
    window.addEventListener("hashchange", this.handlers.hashChangeHandler);

    for (let route of config.routes) {
      this.routes.add(
        new Route({
          ...route,
          /**
           * If the route has no base path (because it's optional), use
           * the router instance's base path.
           */
          basePath: route.basePath || this.config.basePath
        })
      );
    }
  }

  /**
   * Process a state change event from the browser history API.
   *
   * This method is called when the browser history API is used to change the
   * current route via the `pushState`, `replaceState`, or `popState` methods.
   *
   * The method will evaluate the route for the given path and query, and apply
   * the route to the router instance to ultimately call the `applyFn` function
   * on the downstream router component to render the new route.
   *
   * @param {string} path The path to handle the state change for.
   * @param {Query} query The query to handle the state change for.
   * @param {Span} span @optional The span to attach traces to. If not provided,
   * a new span will be created.
   */
  async handleStateChange(url: string, span?: Span): Promise<void> {
    const { path, query } = urls.parse(url);
    this.navigating = true;

    if (!span) {
      span = createSpan("detected history change event");
    }
    span?.trace({
      prefix: "🔍",
      name: "router-instance.handleStateChange",
      description: `attempting to handle a new state change for path "${path}"`,
      metadata: {
        router: {
          id: this.config.id,
          basePath: this.config.basePath
        },
        location: "/src/lib/router-instance.svelte:handleStateChange()",
        basePath: this.config.basePath,
        path,
        query,
        url
      }
    });

    const result = await this.get(path, query, span);

    if (result && SuccessfulConditions.includes(result.result.path.condition)) {
      span?.trace({
        prefix: "✅",
        name: "router-instance.handleStateChange",
        description: `route found for path "${path}"`,
        metadata: {
          location: "/src/lib/router-instance.svelte:handleStateChange()",
          router: {
            id: this.config.id,
            basePath: this.config.basePath
          },
          path,
          query: query?.params || false,
          route: result,
          url
        }
      });

      // Run the global pre hooks:
      if (this.config.hooks?.pre) {
        if (!(await this.evaluateHooks(result, this.config.hooks.pre))) {
          this.navigating = false;
          return;
        }
      }

      // Run the route specific pre hooks:
      if (result.route?.hooks?.pre) {
        if (!(await this.evaluateHooks(result, result.route.hooks.pre))) {
          this.navigating = false;
          return;
        }
      }

      // Contact the downstream router component to apply the route:
      this.applyFn(result, span);

      // Run the route specific post hooks:
      if (result && result.route?.hooks?.post) {
        if (!(await this.evaluateHooks(result, result.route.hooks.post))) {
          this.navigating = false;
          return;
        }
      }

      // Finally, run the global post hooks:
      if (this.config.hooks?.post) {
        await this.evaluateHooks(result, this.config.hooks.post);
      }

      this.current = result;
    }

    this.navigating = false;
  }

  async evaluateHooks(route: RouteResult, hooks: Hook | Hook[]): Promise<boolean> {
    if (Array.isArray(hooks)) {
      for (const hook of hooks) {
        if (!(await execute(() => hook(route)))) {
          return false;
        }

        /**
         * Add small delay between hooks to prevent rapid History API
         * calls causing the browser to halt (firefox specifically).
         */
        await new Promise((resolve) => setTimeout(resolve, 50));
      }
    } else {
      if (!(await execute(() => hooks(route)))) {
        return false;
      }
    }
    return true;
  }

  /**
   * Retrieve a route for a given path.
   *
   * @param {string} path The path to get the route for.
   *
   * @returns {RegistryMatch} The matched route for the given path.
   */
  async get(path: string, query?: Query, span?: Span): Promise<RouteResult> {
    path = path.replace("/#", "");
    const normalized = normalize(path.replace(this.config.basePath || "/", ""));
    const renderDefaultRoute = (reason: string): RouteResult => {
      let defaultRoute: Route;

      for (const route of this.routes) {
        if (!route.path || defaultRoutes.includes(route.path.toString())) {
          defaultRoute = route;
          break;
        }
      }

      span?.trace({
        prefix: defaultRoute ? "✅" : "❌",
        name: "router-instance.getDefaultRoute",
        description: `get default route because "${reason}"`,
        metadata: {
          location: "/src/lib/router-instance.svelte:get()",
          router: {
            id: this.config.id,
            basePath: this.config.basePath
          },
          path,
          query,
          normalized,
          route: defaultRoute
        }
      });

      if (defaultRoute) {
        return new RouteResult({
          route: defaultRoute,
          result: {
            path: {
              condition: "default-match",
              original: path
            },
            querystring: {
              condition: "permitted-no-conditions",
              original: query?.toJSON(),
              params: query?.toJSON()
            },
            component: defaultRoute.component,
            status: StatusCode.OK
          }
        });
      }
    };

    span?.trace({
      prefix: "🔍",
      name: "router-instance.get",
      description: `${this.config.id} with base path "${this.config.basePath || "/"}" is attempting to get a route for path "${path}"`,
      metadata: {
        location: "/src/lib/router-instance.svelte:get()",
        router: {
          id: this.config.id,
          basePath: this.config.basePath
        },
        path,
        query,
        normalized
      }
    });

    if (this.config.basePath === path) {
      return renderDefaultRoute("base path is the same as the path");
    }

    let candidate: RouteResult;

    /**
     * Now we check for router nesting:
     */
    for (const route of this.routes) {
      const pathEvaluation = route.test(normalized);
      if (pathEvaluation && SuccessfulConditions.includes(pathEvaluation.condition)) {
        span?.trace({
          prefix: "✅",
          name: "router-instance.get:routesloop",
          description: `${pathEvaluation.condition} for inbound path "${path}"${route.name ? ` (named: "${route.name}")` : ""}`,
          metadata: {
            location: "/src/lib/router-instance.svelte:get():forloop",
            router: {
              id: this.config.id,
              basePath: this.config.basePath
            },
            path,
            query,
            normalized,
            route,
            evaluation: {
              path: pathEvaluation
            }
          }
        });

        if (route.querystring && query) {
          const queryEvaluation = query.test(route.querystring);
          if (SuccessfulConditions.includes(queryEvaluation?.condition)) {
            span?.trace({
              prefix: "✅",
              name: "router-instance.get.evaluateQuery",
              description: `${queryEvaluation?.condition} evaluating querystring "${query?.toString()}" for the route "${path}"${route.name ? ` (named: "${route.name}")` : ""}`,
              metadata: {
                location: "/src/lib/router-instance.svelte:get()",
                router: {
                  id: this.config.id,
                  basePath: this.config.basePath
                },
                path,
                query,
                normalized,
                evaluation: {
                  path: pathEvaluation,
                  querystring: queryEvaluation
                }
              }
            });
            candidate = new RouteResult({
              route,
              result: {
                path: {
                  ...pathEvaluation,
                  original: normalized
                },
                querystring: {
                  ...queryEvaluation,
                  original: query.toJSON()
                },
                component: route.component,
                status: StatusCode.OK
              }
            });
          }
        } else {
          /**
           * No querystring is configured for this route, so we will
           * use the querystring from the inbound path.
           */
          candidate = new RouteResult({
            route,
            result: {
              path: {
                ...pathEvaluation,
                original: normalized
              },
              querystring: {
                condition: "permitted-no-conditions",
                original: query?.toJSON(),
                params: query?.toJSON()
              },
              component: route.component,
              status: StatusCode.OK
            }
          });
        }
      }
    }

    /**
     * If we've made it this far, we should default to trying to find
     * a route that has no path configured. This will be treated as
     * the "default" route:
     */
    if (path === "/") {
      return renderDefaultRoute("no routes match, last resort is to find a default route");
    }

    /**
     * We've exhaausted all options, so we will attempt to locate
     * a 404 route from the statuses configuration applied to this
     * router instance.
     */
    if (!candidate && this.config.statuses?.[404]) {
      const status = this.config.statuses[404];
      if (typeof status === "function") {
        return {
          result: {
            ...status(
              {
                result: {
                  path: {
                    condition: "permitted-no-conditions",
                    original: path
                  },
                  querystring: {
                    condition: "permitted-no-conditions",
                    original: query?.toJSON(),
                    params: query?.toJSON()
                  },
                  status: StatusCode.NotFound
                }
              },
              span
            ),
            path: {
              condition: "permitted-no-conditions",
              original: path
            },
            querystring: {
              condition: "permitted-no-conditions",
              original: query?.toJSON(),
              params: query?.toJSON()
            },
            status: StatusCode.NotFound
          }
        };
      } else {
        return {
          result: {
            ...(status as object),
            path: {
              condition: "permitted-no-conditions",
              original: path
            },
            querystring: {
              condition: "permitted-no-conditions",
              original: query?.toJSON(),
              params: query?.toJSON()
            },
            status: StatusCode.NotFound
          }
        };
      }
    }

    return candidate;
  }

  /**
   * Deregister a router instance by removing it from the registry and
   * restoring the original history methods.
   *
   * This is called when a router instance is removed from the DOM
   * triggered by the `onDestroy` lifecycle method of the router instance.
   */
  deregister(span?: Span): void {
    window.removeEventListener("pushState", this.handlers.pushStateHandler);
    window.removeEventListener("replaceState", this.handlers.replaceStateHandler);
    window.removeEventListener("popstate", this.handlers.popStateHandler);
    window.removeEventListener("hashchange", this.handlers.hashChangeHandler);

    registry.deregister(this.config.id, span);
  }

  /**
   * Get routes as an array for serialization purposes.
   *
   * @returns {Route[]} The routes as an array.
   */
  get routesArray(): Route[] {
    return Array.from(this.routes);
  }

  /**
   * Custom JSON serialization to handle Set objects properly.
   *
   * @returns {object} The serializable representation of the router instance.
   */
  toJSON(): any {
    return {
      id: this.id,
      config: this.config
    };
  }
}



---
File: /src/lib/router.svelte
---

<script lang="ts">
  import { onDestroy, unmount, type Component } from "svelte";
  import { createSpan, Span } from "./helpers/tracing.svelte";
  import { registry } from "./registry.svelte";
  import { type RouteResult } from "./route.svelte";
  import { RouterInstanceConfig } from "./router-instance-config";
  import type { RouterInstance } from "./router-instance.svelte";

  let { instance = $bindable(), ...rest } = $props<
    { instance?: RouterInstance } & Partial<RouterInstanceConfig> & Record<string, any>
  >();

  const span = createSpan(rest.id ? `[${rest.id}]` : "router");

  let RenderableComponent = $state<Component | null>(null);
  let router: RouterInstance;
  let route: RouteResult = $state();
  let additionalProps = $state<Record<string, any>>({});

  const apply = async (r: RouteResult, span?: Span) => {
    route = r;
    span?.trace({
      prefix: "✅",
      name: "apply",
      description: `<Router${router.config.id ? ` id="${router.config.id}"` : ""}/> applying route ${r.result.path.original} (${r.result.path.condition})`,
      metadata: {
        location: "/src/lib/router.svelte:apply()",
        router: {
          id: router.config.id,
          basePath: router.config.basePath
        },
        result: r
      }
    });
    if (RenderableComponent) {
      unmount(RenderableComponent, {});
      RenderableComponent = null;
    }

    if (typeof r.result.component === "function" && r.result.component.constructor.name === "AsyncFunction") {
      // Handle async component by first awaiting the import:
      const module = await r.result.component();
      RenderableComponent = module.default || module;
    } else {
      // Handle regular component by directly assigning the component:
      RenderableComponent = r.result.component;
    }
    additionalProps = route.route?.props;
  };

  router = registry.register(new RouterInstanceConfig(rest), apply, span);

  span?.trace({
    prefix: "✅",
    name: "<Router/> Component",
    description: "new component mounted",
    metadata: {
      router: {
        id: router.config.id,
        basePath: router.config.basePath
      },
      location: "/src/lib/router.svelte:mount()"
    }
  });

  instance = router;

  if (span) {
    span.metadata = {
      router: router.config.id
    };
  }

  router.handleStateChange(location.toString(), span);

  onDestroy(() => {
    router.deregister(span);
  });

  const { routes, basePath, ...restWithoutRoutes } = rest;
</script>

<RenderableComponent
  {route}
  {...additionalProps}
  {...restWithoutRoutes} />



---
File: /src/lib/statuses.ts
---

import type { Component } from "svelte";

import type { Route, RouteResult } from "./route.svelte";

import type { Span } from "./helpers/tracing.svelte";

/**
 * The available status codes that a route can have called out from the statuses
 * handler mapping.
 *
 * @see {@link Statuses}
 * @category Router
 */
export enum StatusCode {
  OK = 200,
  PermanentRedirect = 301,
  TemporaryRedirect = 302,
  BadRequest = 400,
  Unauthorized = 401,
  Forbidden = 403,
  NotFound = 404,
  InternalServerError = 500
}

/**
 * Route status handler mapping.
 *
 * Status handlers are called with a path and should return a new route
 * or a promise that resolves to a new route.
 *
 * @example
 * ```ts
 * const statuses: Statuses = {
 *   [StatusCode.NotFound]: {
 *     component: NotFound,
 *     props: {
 *       importantInfo: "lets go!"
 *     }
 *   },
 *   [StatusCode.BadRequest]: (path) => {
 *     notifySomething(path);
 *     return {
 *       component: BadRequest,
 *       props: {
 *         importantInfo: "something went wrong..."
 *       }
 *     };
 *   }
 * }
 * ```
 *
 * @see {@link Route}
 * @see {@link StatusCode}
 * @see {@link getStatusByValue}
 * @category Router
 */
export type Statuses = Partial<{
  [K in StatusCode]: (
    result: RouteResult,
    span?: Span
  ) => Route | Promise<Route> | Component<any> | { component: Component<any>; props?: Record<string, any> };
}>;

/**
 * Get the status by value.
 *
 * @param {number} value The value to get the status for.
 * @returns {StatusCode} The status.
 *
 * @see {@link StatusCode}
 * @category Router
 */
export const getStatusByValue = (value: number) => {
  return Object.keys(StatusCode)[Object.values(StatusCode).indexOf(value)];
};



---
File: /src/lib/utilities.svelte.ts
---

/**
 * Wait for a predicate to become true with timeout handling.
 *
 * @param predicate Function that returns boolean to check for
 * @param timeout Time in milliseconds to wait before timing out
 * @throws Error if timeout is reached before predicate becomes true
 *
 * @category utilities
 */
export async function wait(predicate: () => boolean, timeout = 5000): Promise<void> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`Timeout after ${timeout}ms waiting for predicate: ${predicate}`));
    }, timeout);

    const check = async () => {
      if (predicate()) {
        clearTimeout(timer);
        resolve();
      } else {
        setTimeout(check, 50);
      }
    };

    check();
  });
}

/**
 * Check if a value is a promise.
 *
 * @param value - The value to check.
 *
 * @returns True if the value is a promise, false otherwise.
 *
 * @category utilities
 */
export function isPromise(value: any): boolean {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function";
}

/**
 * Execute a function and return a promise if the function is a promise.
 *
 * @param fn - The function to execute.
 *
 * @returns A promise if the function is a promise, otherwise the function result.
 *
 * @category utilities
 */
export const execute = async <T>(fn: () => T | Promise<T>): Promise<T> => {
  if (isPromise(fn)) {
    return await fn();
  } else {
    return fn();
  }
};

/**
 * A reactive map that can be observed for changes using `$state()`.
 *
 * @category utilities
 */
export class ReactiveMap<K, V> extends Map<K, V> {
  #state = $state(false);

  get size() {
    this.#state;
    return super.size;
  }

  #trig() {
    this.#state = !this.#state;
  }

  add(key: K, value: V) {
    if (this.has(key)) {
      throw new Error(`key ${key} already exists`);
    }
    return this.set(key, value);
  }

  get(key: K) {
    this.#state;
    return super.get(key);
  }

  set(key: K, value: V) {
    const result = super.set(key, value);
    this.#trig();
    return result;
  }

  delete(key: K) {
    const result = super.delete(key);
    if (result) this.#trig();
    return result;
  }

  clear() {
    const result = super.clear();
    this.#trig();
    return result;
  }

  keys() {
    this.#state;
    return super.keys();
  }
  values() {
    this.#state;
    return super.values();
  }
  entries() {
    this.#state;
    return super.entries();
  }
  forEach(fn: (value: V, key: K, map: Map<K, V>) => void) {
    this.#state;
    return super.forEach(fn);
  }

  [Symbol.iterator]() {
    this.#state;
    return super[Symbol.iterator]();
  }
}



---
File: /src/vite-env.d.ts
---

/// <reference types="vite/client" />

import type { TracingConfig } from "@mateothegreat/svelte5-router";

interface ImportMetaEnv {
  readonly SPA_ROUTER: {
    logLevel: "debug" | "info" | "warn" | "error";
    tracing: TracingConfig;
  };
}



---
File: /svelte.config.ts
---

import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";

export default {
	preprocess: [vitePreprocess({})]
};



---
File: /vite.config.ts
---

import { svelte } from "@sveltejs/vite-plugin-svelte";

import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

import { sveltePreprocess } from "svelte-preprocess";

export default defineConfig({
  plugins: [
    tsconfigPaths(),
    svelte({
      preprocess: [sveltePreprocess({ typescript: true })]
    })
  ]
});



---
File: /vitest.config.ts
---

import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    coverage: {
      reporter: ["json-summary"],
      reportsDirectory: "tmp/coverage"
    }
  }
});



---
File: /vitest.setup.ts
---

import '@testing-library/jest-dom/vitest';

