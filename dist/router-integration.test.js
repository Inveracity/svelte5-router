import { describe, it, expect, vi, beforeEach } from 'vitest';
describe('Router Remount Integration', () => {
    it('should detect same route navigation correctly', () => {
        const route1 = {
            result: {
                path: { original: '/test' },
                querystring: { params: { foo: 'bar' } }
            }
        };
        const route2 = {
            result: {
                path: { original: '/test' },
                querystring: { params: { foo: 'bar' } }
            }
        };
        const route3 = {
            result: {
                path: { original: '/test' },
                querystring: { params: { foo: 'different' } }
            }
        };
        const isSameRoute = (current, result) => {
            return !!(current &&
                current.result.path.original === result.result.path.original &&
                JSON.stringify(current.result.querystring.params) === JSON.stringify(result.result.querystring.params));
        };
        expect(isSameRoute(route1, route2)).toBe(true);
        expect(isSameRoute(route1, route3)).toBe(false);
        expect(isSameRoute(null, route1)).toBe(false);
    });
    it('should determine when to apply route based on renavigation config', () => {
        const current = {
            result: {
                path: { original: '/test' },
                querystring: { params: {} }
            }
        };
        const newRoute = {
            result: {
                path: { original: '/test' },
                querystring: { params: {} }
            }
        };
        const shouldApply = (current, result, renavigation) => {
            const isSameRoute = current &&
                current.result.path.original === result.result.path.original &&
                JSON.stringify(current.result.querystring.params) === JSON.stringify(result.result.querystring.params);
            return !isSameRoute || renavigation !== false;
        };
        expect(shouldApply(current, newRoute, undefined)).toBe(true);
        expect(shouldApply(current, newRoute, true)).toBe(true);
        expect(shouldApply(current, newRoute, false)).toBe(false);
        const differentRoute = {
            result: {
                path: { original: '/different' },
                querystring: { params: {} }
            }
        };
        expect(shouldApply(current, differentRoute, false)).toBe(true);
    });
    it('should handle query parameter differences correctly', () => {
        const current = {
            result: {
                path: { original: '/test' },
                querystring: { params: { a: '1', b: '2' } }
            }
        };
        const sameQuery = {
            result: {
                path: { original: '/test' },
                querystring: { params: { a: '1', b: '2' } }
            }
        };
        const differentQuery = {
            result: {
                path: { original: '/test' },
                querystring: { params: { a: '1', b: '3' } }
            }
        };
        const isSameRoute = (current, result) => {
            return !!(current &&
                current.result.path.original === result.result.path.original &&
                JSON.stringify(current.result.querystring.params) === JSON.stringify(result.result.querystring.params));
        };
        expect(isSameRoute(current, sameQuery)).toBe(true);
        expect(isSameRoute(current, differentQuery)).toBe(false);
    });
});
